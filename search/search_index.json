{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Fab Futures","text":"<p>Welcome to the Fab Futures chip design course materials.</p>"},{"location":"#lectures","title":"Lectures","text":"<ol> <li>Introduction &amp; Pipeline - Overview of the chip design flow</li> <li>Analog Basics - Fundamentals of analog circuit design</li> <li>Schematic &amp; Simulation - Circuit capture and simulation</li> <li>Layout &amp; Fabrication - Physical design and manufacturing</li> <li>RTL Design &amp; Verification - Digital design with HDLs</li> <li>Synthesis &amp; Physical Design - From RTL to layout</li> <li>Packaging &amp; Board Design - Chip packaging and PCB integration</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To run the notebooks locally, clone the repository and install the dependencies:</p> <pre><code>git clone https://github.com/AlexWynn-AM/fab-futures.git\ncd fab-futures\npip install -r requirements.txt\njupyter lab\n</code></pre>"},{"location":"notebooks/01_introduction_pipeline/","title":"Introduction & Development Pipeline","text":"Introduction &amp; Development Pipeline <p>Week 1, Session 1 \u2014 Fab Futures</p> In\u00a0[1]: Copied! <pre># Setup: Import libraries for visualizations\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import FancyBboxPatch, FancyArrowPatch\nimport numpy as np\n\n# Color scheme\nCOLORS = {\n    'primary': '#2196F3',\n    'secondary': '#FF9800',\n    'success': '#4CAF50',\n    'danger': '#f44336',\n    'dark': '#1a1a2e',\n    'light': '#f5f5f5'\n}\n\nprint(\"Setup complete.\")\n</pre> # Setup: Import libraries for visualizations import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.patches import FancyBboxPatch, FancyArrowPatch import numpy as np  # Color scheme COLORS = {     'primary': '#2196F3',     'secondary': '#FF9800',     'success': '#4CAF50',     'danger': '#f44336',     'dark': '#1a1a2e',     'light': '#f5f5f5' }  print(\"Setup complete.\") <pre>Setup complete.\n</pre> <p></p> <p></p> <p>An integrated circuit (IC) or chip is a set of electronic circuits on a small flat piece of semiconductor material (usually silicon).</p> In\u00a0[2]: Copied! <pre># Visualize: From sand to chip\nfig, axes = plt.subplots(1, 5, figsize=(16, 3))\n\nstages = [\n    ('Sand\\n(SiO2)', '#DEB887', '1'),\n    ('Purified\\nSilicon', '#A9A9A9', '2'),\n    ('Silicon\\nIngot', '#708090', '3'),\n    ('Wafer\\n(300mm)', '#B8B8B8', '4'),\n    ('Chips\\n(Diced)', '#4169E1', '5'),\n]\n\nfor ax, (label, color, num) in zip(axes, stages):\n    circle = plt.Circle((0.5, 0.5), 0.35, color=color, ec='black', linewidth=2)\n    ax.add_patch(circle)\n    ax.text(0.5, 0.5, num, ha='center', va='center', fontsize=20, fontweight='bold')\n    ax.text(0.5, -0.1, label, ha='center', va='top', fontsize=10, fontweight='bold')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(-0.3, 1)\n    ax.set_aspect('equal')\n    ax.axis('off')\n\n# Add arrows between stages\nfor i in range(len(axes) - 1):\n    fig.text(0.12 + i * 0.195, 0.5, '--&gt;', fontsize=16, ha='center', va='center', family='monospace')\n\nplt.suptitle('From Sand to Silicon Chips', fontsize=14, fontweight='bold', y=1.02)\nplt.tight_layout()\nplt.show()\n</pre> # Visualize: From sand to chip fig, axes = plt.subplots(1, 5, figsize=(16, 3))  stages = [     ('Sand\\n(SiO2)', '#DEB887', '1'),     ('Purified\\nSilicon', '#A9A9A9', '2'),     ('Silicon\\nIngot', '#708090', '3'),     ('Wafer\\n(300mm)', '#B8B8B8', '4'),     ('Chips\\n(Diced)', '#4169E1', '5'), ]  for ax, (label, color, num) in zip(axes, stages):     circle = plt.Circle((0.5, 0.5), 0.35, color=color, ec='black', linewidth=2)     ax.add_patch(circle)     ax.text(0.5, 0.5, num, ha='center', va='center', fontsize=20, fontweight='bold')     ax.text(0.5, -0.1, label, ha='center', va='top', fontsize=10, fontweight='bold')     ax.set_xlim(0, 1)     ax.set_ylim(-0.3, 1)     ax.set_aspect('equal')     ax.axis('off')  # Add arrows between stages for i in range(len(axes) - 1):     fig.text(0.12 + i * 0.195, 0.5, '--&gt;', fontsize=16, ha='center', va='center', family='monospace')  plt.suptitle('From Sand to Silicon Chips', fontsize=14, fontweight='bold', y=1.02) plt.tight_layout() plt.show() <p></p> In\u00a0[3]: Copied! <pre># Compare ASIC vs FPGA vs Standard Products\nfig, ax = plt.subplots(figsize=(12, 6))\n\ncategories = ['Development\\nCost', 'Unit\\nCost', 'Performance', 'Flexibility', 'Time to\\nMarket']\nasic = [9, 2, 10, 1, 2]\nfpga = [4, 6, 6, 8, 8]\nstandard = [1, 5, 5, 3, 10]\n\nx = np.arange(len(categories))\nwidth = 0.25\n\nbars1 = ax.bar(x - width, asic, width, label='ASIC', color=COLORS['primary'])\nbars2 = ax.bar(x, fpga, width, label='FPGA', color=COLORS['secondary'])\nbars3 = ax.bar(x + width, standard, width, label='Standard IC', color=COLORS['success'])\n\nax.set_ylabel('Score (1-10)', fontsize=11)\nax.set_title('ASIC vs FPGA vs Standard Products', fontsize=14, fontweight='bold')\nax.set_xticks(x)\nax.set_xticklabels(categories, fontsize=10)\nax.legend(loc='upper right')\nax.set_ylim(0, 12)\nax.grid(axis='y', alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\nprint(\"ASIC: Best for high-volume production where performance matters\")\nprint(\"FPGA: Best for prototyping and medium-volume with changing requirements\")\nprint(\"Standard: Best for quick development with standard functionality\")\n</pre> # Compare ASIC vs FPGA vs Standard Products fig, ax = plt.subplots(figsize=(12, 6))  categories = ['Development\\nCost', 'Unit\\nCost', 'Performance', 'Flexibility', 'Time to\\nMarket'] asic = [9, 2, 10, 1, 2] fpga = [4, 6, 6, 8, 8] standard = [1, 5, 5, 3, 10]  x = np.arange(len(categories)) width = 0.25  bars1 = ax.bar(x - width, asic, width, label='ASIC', color=COLORS['primary']) bars2 = ax.bar(x, fpga, width, label='FPGA', color=COLORS['secondary']) bars3 = ax.bar(x + width, standard, width, label='Standard IC', color=COLORS['success'])  ax.set_ylabel('Score (1-10)', fontsize=11) ax.set_title('ASIC vs FPGA vs Standard Products', fontsize=14, fontweight='bold') ax.set_xticks(x) ax.set_xticklabels(categories, fontsize=10) ax.legend(loc='upper right') ax.set_ylim(0, 12) ax.grid(axis='y', alpha=0.3)  plt.tight_layout() plt.show()  print(\"ASIC: Best for high-volume production where performance matters\") print(\"FPGA: Best for prototyping and medium-volume with changing requirements\") print(\"Standard: Best for quick development with standard functionality\") <pre>ASIC: Best for high-volume production where performance matters\nFPGA: Best for prototyping and medium-volume with changing requirements\nStandard: Best for quick development with standard functionality\n</pre> <p></p> In\u00a0[4]: Copied! <pre># Hierarchy visualization\nfig, ax = plt.subplots(figsize=(14, 8))\n\nlevels = [\n    ('Transistor', 'NMOS, PMOS', '~5nm - 100nm', '#E3F2FD'),\n    ('Logic Gate', 'NAND, NOR, INV', '~10-100 transistors', '#BBDEFB'),\n    ('Standard Cell', 'Flip-flop, Mux, Adder', '~10-1000 gates', '#90CAF9'),\n    ('Module', 'ALU, Register File, FSM', '~100-10K cells', '#64B5F6'),\n    ('Block/IP', 'CPU Core, UART, SPI', '~1K-1M cells', '#42A5F5'),\n    ('Chip/SoC', 'Complete IC', '~1M-10B transistors', '#2196F3'),\n    ('Package', 'QFP, BGA, Chiplet', 'Mounted on PCB', '#1976D2'),\n    ('System', 'Phone, Computer, Car', 'Multiple chips + software', '#1565C0'),\n]\n\nfor i, (name, example, scale, color) in enumerate(levels):\n    y = len(levels) - i - 1\n    # Main box\n    rect = FancyBboxPatch((1, y * 1.2), 3, 0.9, boxstyle=\"round,pad=0.05\",\n                          facecolor=color, edgecolor='black', linewidth=2)\n    ax.add_patch(rect)\n    ax.text(2.5, y * 1.2 + 0.45, name, ha='center', va='center', \n            fontsize=12, fontweight='bold')\n    \n    # Example\n    ax.text(5, y * 1.2 + 0.6, example, ha='left', va='center', fontsize=10)\n    ax.text(5, y * 1.2 + 0.25, scale, ha='left', va='center', fontsize=9, \n            style='italic', color='gray')\n    \n    # Arrow to next level\n    if i &lt; len(levels) - 1:\n        ax.annotate('', xy=(2.5, (y-1) * 1.2 + 0.9), xytext=(2.5, y * 1.2),\n                   arrowprops=dict(arrowstyle='-&gt;', color='gray', lw=1.5))\n\nax.set_xlim(0, 10)\nax.set_ylim(-0.5, len(levels) * 1.2 + 0.5)\nax.set_title('Design Hierarchy: Transistor to System', fontsize=14, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Hierarchy visualization fig, ax = plt.subplots(figsize=(14, 8))  levels = [     ('Transistor', 'NMOS, PMOS', '~5nm - 100nm', '#E3F2FD'),     ('Logic Gate', 'NAND, NOR, INV', '~10-100 transistors', '#BBDEFB'),     ('Standard Cell', 'Flip-flop, Mux, Adder', '~10-1000 gates', '#90CAF9'),     ('Module', 'ALU, Register File, FSM', '~100-10K cells', '#64B5F6'),     ('Block/IP', 'CPU Core, UART, SPI', '~1K-1M cells', '#42A5F5'),     ('Chip/SoC', 'Complete IC', '~1M-10B transistors', '#2196F3'),     ('Package', 'QFP, BGA, Chiplet', 'Mounted on PCB', '#1976D2'),     ('System', 'Phone, Computer, Car', 'Multiple chips + software', '#1565C0'), ]  for i, (name, example, scale, color) in enumerate(levels):     y = len(levels) - i - 1     # Main box     rect = FancyBboxPatch((1, y * 1.2), 3, 0.9, boxstyle=\"round,pad=0.05\",                           facecolor=color, edgecolor='black', linewidth=2)     ax.add_patch(rect)     ax.text(2.5, y * 1.2 + 0.45, name, ha='center', va='center',              fontsize=12, fontweight='bold')          # Example     ax.text(5, y * 1.2 + 0.6, example, ha='left', va='center', fontsize=10)     ax.text(5, y * 1.2 + 0.25, scale, ha='left', va='center', fontsize=9,              style='italic', color='gray')          # Arrow to next level     if i &lt; len(levels) - 1:         ax.annotate('', xy=(2.5, (y-1) * 1.2 + 0.9), xytext=(2.5, y * 1.2),                    arrowprops=dict(arrowstyle='-&gt;', color='gray', lw=1.5))  ax.set_xlim(0, 10) ax.set_ylim(-0.5, len(levels) * 1.2 + 0.5) ax.set_title('Design Hierarchy: Transistor to System', fontsize=14, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show() <p></p> In\u00a0[5]: Copied! <pre># Development pipeline visualization\nfig, ax = plt.subplots(figsize=(16, 10))\n\n# Define the pipeline stages\nstages = [\n    ('Specification', 'What should the chip do?', '#E8F5E9', 0),\n    ('Architecture', 'High-level block diagram', '#E8F5E9', 0),\n    ('RTL Design', 'Verilog/VHDL code', '#E3F2FD', 1),\n    ('Simulation', 'Verify functionality', '#E3F2FD', 1),\n    ('Synthesis', 'Convert to gates', '#FFF3E0', 2),\n    ('Place &amp; Route', 'Physical layout', '#FFF3E0', 2),\n    ('Timing Analysis', 'Check speed', '#FFF3E0', 2),\n    ('DRC/LVS', 'Verify layout rules', '#FCE4EC', 3),\n    ('Tape Out', 'Send to fab', '#FCE4EC', 3),\n    ('Fabrication', '1-6 months wait', '#F3E5F5', 4),\n    ('Packaging', 'Dice &amp; package', '#F3E5F5', 4),\n    ('Testing', 'Verify silicon', '#E0F2F1', 5),\n]\n\nphase_labels = ['Design', 'Verification', 'Physical', 'Signoff', 'Manufacturing', 'Validation']\nphase_colors = ['#4CAF50', '#2196F3', '#FF9800', '#E91E63', '#9C27B0', '#009688']\n\n# Draw stages\nfor i, (name, desc, color, phase) in enumerate(stages):\n    y = len(stages) - i - 1\n    \n    # Stage box\n    rect = FancyBboxPatch((2, y * 0.8), 4, 0.6, boxstyle=\"round,pad=0.05\",\n                          facecolor=color, edgecolor=phase_colors[phase], linewidth=2)\n    ax.add_patch(rect)\n    ax.text(4, y * 0.8 + 0.3, name, ha='center', va='center', \n            fontsize=11, fontweight='bold')\n    ax.text(6.5, y * 0.8 + 0.3, desc, ha='left', va='center', fontsize=10, color='gray')\n    \n    # Arrow\n    if i &lt; len(stages) - 1:\n        ax.annotate('', xy=(4, (y-1) * 0.8 + 0.6), xytext=(4, y * 0.8),\n                   arrowprops=dict(arrowstyle='-&gt;', color='gray', lw=1.5))\n\n# Phase indicators on the left\nphase_positions = [10.5, 8.5, 6.5, 4.5, 2.5, 0.5]\nfor i, (label, color, ypos) in enumerate(zip(phase_labels, phase_colors, phase_positions)):\n    ax.add_patch(FancyBboxPatch((0, ypos * 0.8 - 0.1), 1.5, 0.8, \n                 boxstyle=\"round,pad=0.02\", facecolor=color, alpha=0.3))\n    ax.text(0.75, ypos * 0.8 + 0.3, label, ha='center', va='center', \n            fontsize=9, fontweight='bold', rotation=0)\n\nax.set_xlim(-0.5, 12)\nax.set_ylim(-0.5, len(stages) * 0.8 + 0.5)\nax.set_title('Chip Development Pipeline', fontsize=14, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Development pipeline visualization fig, ax = plt.subplots(figsize=(16, 10))  # Define the pipeline stages stages = [     ('Specification', 'What should the chip do?', '#E8F5E9', 0),     ('Architecture', 'High-level block diagram', '#E8F5E9', 0),     ('RTL Design', 'Verilog/VHDL code', '#E3F2FD', 1),     ('Simulation', 'Verify functionality', '#E3F2FD', 1),     ('Synthesis', 'Convert to gates', '#FFF3E0', 2),     ('Place &amp; Route', 'Physical layout', '#FFF3E0', 2),     ('Timing Analysis', 'Check speed', '#FFF3E0', 2),     ('DRC/LVS', 'Verify layout rules', '#FCE4EC', 3),     ('Tape Out', 'Send to fab', '#FCE4EC', 3),     ('Fabrication', '1-6 months wait', '#F3E5F5', 4),     ('Packaging', 'Dice &amp; package', '#F3E5F5', 4),     ('Testing', 'Verify silicon', '#E0F2F1', 5), ]  phase_labels = ['Design', 'Verification', 'Physical', 'Signoff', 'Manufacturing', 'Validation'] phase_colors = ['#4CAF50', '#2196F3', '#FF9800', '#E91E63', '#9C27B0', '#009688']  # Draw stages for i, (name, desc, color, phase) in enumerate(stages):     y = len(stages) - i - 1          # Stage box     rect = FancyBboxPatch((2, y * 0.8), 4, 0.6, boxstyle=\"round,pad=0.05\",                           facecolor=color, edgecolor=phase_colors[phase], linewidth=2)     ax.add_patch(rect)     ax.text(4, y * 0.8 + 0.3, name, ha='center', va='center',              fontsize=11, fontweight='bold')     ax.text(6.5, y * 0.8 + 0.3, desc, ha='left', va='center', fontsize=10, color='gray')          # Arrow     if i &lt; len(stages) - 1:         ax.annotate('', xy=(4, (y-1) * 0.8 + 0.6), xytext=(4, y * 0.8),                    arrowprops=dict(arrowstyle='-&gt;', color='gray', lw=1.5))  # Phase indicators on the left phase_positions = [10.5, 8.5, 6.5, 4.5, 2.5, 0.5] for i, (label, color, ypos) in enumerate(zip(phase_labels, phase_colors, phase_positions)):     ax.add_patch(FancyBboxPatch((0, ypos * 0.8 - 0.1), 1.5, 0.8,                   boxstyle=\"round,pad=0.02\", facecolor=color, alpha=0.3))     ax.text(0.75, ypos * 0.8 + 0.3, label, ha='center', va='center',              fontsize=9, fontweight='bold', rotation=0)  ax.set_xlim(-0.5, 12) ax.set_ylim(-0.5, len(stages) * 0.8 + 0.5) ax.set_title('Chip Development Pipeline', fontsize=14, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show() <p></p> In\u00a0[6]: Copied! <pre># Tool flow visualization\nfig, ax = plt.subplots(figsize=(14, 6))\n\ntools = [\n    ('Verilog\\nCode', 'Your\\nDesign', '#E8F5E9'),\n    ('Icarus\\nVerilog', 'Simulate', '#E3F2FD'),\n    ('Yosys', 'Synthesize', '#FFF3E0'),\n    ('OpenROAD', 'Place &amp;\\nRoute', '#FCE4EC'),\n    ('Magic/\\nKLayout', 'Verify\\nDRC/LVS', '#F3E5F5'),\n    ('GDS\\nFile', 'Tape\\nOut!', '#E0F2F1'),\n]\n\nfor i, (tool, action, color) in enumerate(tools):\n    x = i * 2.2 + 0.5\n    \n    # Tool box\n    rect = FancyBboxPatch((x, 1), 1.8, 1.5, boxstyle=\"round,pad=0.1\",\n                          facecolor=color, edgecolor='black', linewidth=2)\n    ax.add_patch(rect)\n    ax.text(x + 0.9, 2.1, tool, ha='center', va='center', fontsize=10, fontweight='bold')\n    ax.text(x + 0.9, 1.4, action, ha='center', va='center', fontsize=9, color='gray')\n    \n    # Arrow\n    if i &lt; len(tools) - 1:\n        ax.annotate('', xy=(x + 2.0, 1.75), xytext=(x + 1.8, 1.75),\n                   arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))\n\nax.set_xlim(0, 14)\nax.set_ylim(0, 4)\nax.set_title('Open Source RTL-to-GDS Flow', fontsize=14, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Tool flow visualization fig, ax = plt.subplots(figsize=(14, 6))  tools = [     ('Verilog\\nCode', 'Your\\nDesign', '#E8F5E9'),     ('Icarus\\nVerilog', 'Simulate', '#E3F2FD'),     ('Yosys', 'Synthesize', '#FFF3E0'),     ('OpenROAD', 'Place &amp;\\nRoute', '#FCE4EC'),     ('Magic/\\nKLayout', 'Verify\\nDRC/LVS', '#F3E5F5'),     ('GDS\\nFile', 'Tape\\nOut!', '#E0F2F1'), ]  for i, (tool, action, color) in enumerate(tools):     x = i * 2.2 + 0.5          # Tool box     rect = FancyBboxPatch((x, 1), 1.8, 1.5, boxstyle=\"round,pad=0.1\",                           facecolor=color, edgecolor='black', linewidth=2)     ax.add_patch(rect)     ax.text(x + 0.9, 2.1, tool, ha='center', va='center', fontsize=10, fontweight='bold')     ax.text(x + 0.9, 1.4, action, ha='center', va='center', fontsize=9, color='gray')          # Arrow     if i &lt; len(tools) - 1:         ax.annotate('', xy=(x + 2.0, 1.75), xytext=(x + 1.8, 1.75),                    arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))  ax.set_xlim(0, 14) ax.set_ylim(0, 4) ax.set_title('Open Source RTL-to-GDS Flow', fontsize=14, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show() <p></p> <p>A PDK tells your tools how to design for a specific manufacturing process.</p> <p></p> <p>Several programs make chip fabrication accessible to students, hobbyists, and researchers.</p> <p></p>"},{"location":"notebooks/01_introduction_pipeline/#contents","title":"Contents\u00b6","text":"<ol> <li>What Can You Build? -- Start here!</li> <li>What is a Chip?</li> <li>Types of Integrated Circuits</li> <li>From Transistor to System</li> <li>The Development Pipeline</li> <li>Tools &amp; Ecosystem</li> <li>Process Development Kits (PDKs)</li> <li>Low-Cost Tapeout Options</li> <li>Version Control for Hardware</li> </ol>"},{"location":"notebooks/01_introduction_pipeline/#1-what-can-you-build","title":"1. What Can You Build?\u00b6","text":"<p>Before diving into technical details, let's see what's possible. Real people have designed real chips that do fun, creative things\u2014and had them manufactured on silicon.</p>"},{"location":"notebooks/01_introduction_pipeline/#silicon-proven-examples","title":"Silicon-Proven Examples\u00b6","text":"<p>These projects have been fabricated and tested on actual hardware:</p> Project What It Does Source Code Analog Emulation Monosynth Two oscillators + filter = music on a chip GitHub TTRPG Dice D4, D6, D8, D10, D12, D20 dice with 7-seg display GitHub Super Mario Tune Plays the Mario theme on a piezo speaker GitHub Simon Says Classic memory game with LEDs and audio GitHub <p>Browse more at tinytapeout.com/chips/silicon-proven</p>"},{"location":"notebooks/01_introduction_pipeline/#our-course-projects","title":"Our Course Projects\u00b6","text":"<p>You'll build similar projects:</p> <ul> <li>Fortune Teller \u2014 Magic 8-ball that outputs predictions over UART</li> <li>Pocket Synth \u2014 4-button synthesizer with PWM audio output</li> <li>Dice Roller \u2014 Digital dice with 7-segment display</li> <li>LED Messenger \u2014 Scrolling text on WS2812 RGB LEDs</li> </ul> <p>The goal: By the end of this course, you'll understand how to take a project from Verilog code to silicon.</p>"},{"location":"notebooks/01_introduction_pipeline/#2-what-is-a-chip","title":"2. What is a Chip?\u00b6","text":""},{"location":"notebooks/01_introduction_pipeline/#why-silicon","title":"Why Silicon?\u00b6","text":"Property Why It Matters Semiconductor Can be made conductive or insulating by doping Abundant Second most common element in Earth's crust (sand!) Stable oxide SiO\u2082 is an excellent insulator Crystalline Regular atomic structure enables precise manufacturing"},{"location":"notebooks/01_introduction_pipeline/#3-types-of-integrated-circuits","title":"3. Types of Integrated Circuits\u00b6","text":""},{"location":"notebooks/01_introduction_pipeline/#by-function","title":"By Function\u00b6","text":"Type Examples Characteristics Microprocessors (CPUs) Intel Core, AMD Ryzen, Apple M-series General-purpose computation Microcontrollers (MCUs) Arduino (ATmega), ESP32, STM32 CPU + memory + peripherals on one chip Memory DRAM, SRAM, Flash Data storage Analog/Mixed-Signal ADCs, DACs, amplifiers Interface between analog and digital RF/Wireless WiFi, Bluetooth, cellular Radio frequency communication Power Management Voltage regulators, battery chargers Power conversion and distribution Sensors Accelerometers, temperature, image sensors Convert physical quantities to electrical signals"},{"location":"notebooks/01_introduction_pipeline/#by-design-approach","title":"By Design Approach\u00b6","text":"Type Description Use Case ASIC Application-Specific IC High volume, optimized for one task FPGA Field-Programmable Gate Array Prototyping, reconfigurable logic Standard Products Off-the-shelf ICs General-purpose building blocks"},{"location":"notebooks/01_introduction_pipeline/#4-from-transistor-to-system","title":"4. From Transistor to System\u00b6","text":""},{"location":"notebooks/01_introduction_pipeline/#5-the-development-pipeline","title":"5. The Development Pipeline\u00b6","text":""},{"location":"notebooks/01_introduction_pipeline/#our-course-focus","title":"Our Course Focus\u00b6","text":"<p>In this course, you'll experience the full chip development flow:</p> <ul> <li>Analog fundamentals: Transistors, SPICE simulation, device behavior</li> <li>Digital design: Verilog, synthesis, place &amp; route, timing analysis</li> <li>Physical design: Layout, DRC, LVS, tapeout</li> </ul> <p>Your project work will focus on the RTL-to-GDS flow for digital circuits:</p> <pre><code>Verilog Code \u2192 Simulation \u2192 Synthesis \u2192 Place &amp; Route \u2192 GDS\n</code></pre> <p>This flow is highly automated, which lets you iterate quickly and focus on what your chip does rather than hand-drawing every transistor.</p>"},{"location":"notebooks/01_introduction_pipeline/#6-tools-ecosystem","title":"6. Tools &amp; Ecosystem\u00b6","text":""},{"location":"notebooks/01_introduction_pipeline/#open-source-tools-what-we-use","title":"Open Source Tools (What We Use)\u00b6","text":"Tool Purpose Stage Icarus Verilog Simulation Design Verilator Fast simulation + linting Design GTKWave Waveform viewer Verification Yosys Synthesis Physical OpenROAD Place &amp; Route Physical Magic Layout editor &amp; DRC Signoff KLayout Layout viewer &amp; DRC Signoff Netgen LVS checking Signoff"},{"location":"notebooks/01_introduction_pipeline/#commercial-tools-industry-standard","title":"Commercial Tools (Industry Standard)\u00b6","text":"Vendor Tools Cadence Genus (synthesis), Innovus (P&amp;R), Virtuoso (analog) Synopsys Design Compiler, IC Compiler, VCS Siemens EDA Questa (simulation), Calibre (DRC/LVS)"},{"location":"notebooks/01_introduction_pipeline/#7-process-development-kits-pdks","title":"7. Process Development Kits (PDKs)\u00b6","text":""},{"location":"notebooks/01_introduction_pipeline/#whats-in-a-pdk","title":"What's in a PDK?\u00b6","text":"Component Description Design Rules Minimum widths, spacings, enclosures Device Models SPICE models for transistors Standard Cells Pre-designed logic gates I/O Cells Pads for chip inputs/outputs Tech Files Layer definitions, colors, connectivity"},{"location":"notebooks/01_introduction_pipeline/#open-pdks-we-can-use","title":"Open PDKs We Can Use\u00b6","text":"PDK Node Provider Notes SkyWater 130nm 130nm Google/SkyWater Most mature open PDK GlobalFoundries 180nm 180nm GF/Efabless Good for analog IHP 130nm 130nm IHP SiGe BiCMOS available"},{"location":"notebooks/01_introduction_pipeline/#8-low-cost-tapeout-options","title":"8. Low-Cost Tapeout Options\u00b6","text":""},{"location":"notebooks/01_introduction_pipeline/#educational-hobbyist-programs","title":"Educational &amp; Hobbyist Programs\u00b6","text":"Program Cost Details Tiny Tapeout ~$100-300 Shared shuttle, small tiles (~160x225 um) Efabless ChipIgnite ~$10K (scholarships available) Full chip area, SkyWater 130nm Google/Efabless MPW Free (competitive) Requires open source <p>These programs use multi-project wafers (MPW) to share fabrication costs across many designs.</p>"},{"location":"notebooks/01_introduction_pipeline/#research-startup-options","title":"Research &amp; Startup Options\u00b6","text":"Option Cost Range Typical Use MPW Shuttles $20K-100K Prototype runs, small teams Dedicated Run $100K-10M+ Production volumes"},{"location":"notebooks/01_introduction_pipeline/#choosing-a-path","title":"Choosing a Path\u00b6","text":"<p>For this course, any of the educational programs work. The design flow is the same\u2014only the area constraints and submission process differ. Check current specifications at each program's website, as shuttle schedules and requirements change.</p>"},{"location":"notebooks/01_introduction_pipeline/#9-version-control-for-hardware","title":"9. Version Control for Hardware\u00b6","text":""},{"location":"notebooks/01_introduction_pipeline/#why-version-control","title":"Why Version Control?\u00b6","text":"<ul> <li>Track changes: See what changed and when</li> <li>Collaborate: Multiple people working on same design</li> <li>Revert mistakes: Go back to a working version</li> <li>Branches: Try experimental changes safely</li> </ul>"},{"location":"notebooks/01_introduction_pipeline/#git-basics-for-hardware-projects","title":"Git Basics for Hardware Projects\u00b6","text":"<pre># Initialize a new repository\ngit init\n\n# Stage changes\ngit add mydesign.v testbench.v\n\n# Commit with a message\ngit commit -m \"Add UART transmitter module\"\n\n# View history\ngit log --oneline\n</pre>"},{"location":"notebooks/01_introduction_pipeline/#what-to-track-vs-ignore","title":"What to Track vs Ignore\u00b6","text":"Track (commit these) Ignore (.gitignore) Verilog source (.v) Simulation outputs (.vcd, .vvp) Testbenches Build artifacts Constraints (.sdc) Generated netlists Documentation Large binary files"},{"location":"notebooks/01_introduction_pipeline/#summary","title":"Summary\u00b6","text":"<ul> <li>Chips are integrated circuits built on silicon</li> <li>The development pipeline goes from specification to tested silicon</li> <li>We'll use open source tools (Yosys, OpenROAD, Magic)</li> <li>PDKs define how to design for a specific fab process</li> <li>Low-cost tapeout options make custom silicon accessible</li> </ul>"},{"location":"notebooks/01_introduction_pipeline/#homework","title":"Homework\u00b6","text":"<ol> <li>Install the course toolchain (Docker container)</li> <li>Run a \"hello world\" synthesis</li> <li>Verify your tools work before Thursday!</li> </ol>"},{"location":"notebooks/02_analog_basics/","title":"Analog Basics","text":"Analog Basics <p>Week 1, Session 2 \u2014 Fab Futures</p> In\u00a0[1]: Copied! <pre># Setup\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import FancyBboxPatch, Circle, FancyArrowPatch, Arc\nimport numpy as np\n\n# For circuit-like drawings\nplt.rcParams['font.family'] = 'monospace'\n\nprint(\"Setup complete.\")\n</pre> # Setup import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.patches import FancyBboxPatch, Circle, FancyArrowPatch, Arc import numpy as np  # For circuit-like drawings plt.rcParams['font.family'] = 'monospace'  print(\"Setup complete.\") <pre>Setup complete.\n</pre> <p></p> In\u00a0[2]: Copied! <pre># Visualize metal stackup\nfig = plt.figure(figsize=(12, 6))\nax = fig.add_subplot(111, projection='3d')\n\n# Colors for each layer\ncolors = ['#8B4513', '#808080', '#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#E91E63']\nlabels = ['Substrate', 'Poly', 'M1', 'M2', 'M3', 'M4', 'M5']\nheights = [0, 0.5, 1.0, 1.8, 2.6, 3.4, 4.2]\nthicknesses = [0.4, 0.1, 0.3, 0.4, 0.4, 0.5, 0.6]\n\nfor i, (color, label, z, thick) in enumerate(zip(colors, labels, heights, thicknesses)):\n    # Draw each layer as a semi-transparent box\n    if i == 0:  # Substrate - full\n        xx, yy = np.meshgrid([0, 10], [0, 10])\n        ax.plot_surface(xx, yy, np.ones_like(xx) * z, alpha=0.7, color=color)\n    else:  # Metal layers - partial for visibility\n        # Horizontal stripe\n        xx, yy = np.meshgrid([1, 9], [4 + i*0.3, 6 - i*0.3])\n        ax.plot_surface(xx, yy, np.ones_like(xx) * z, alpha=0.8, color=color)\n    \n    ax.text(11, 5, z + thick/2, label, fontsize=10)\n\n# Add via between M1 and M2\nax.bar3d(5, 5, 1.0, 0.5, 0.5, 0.8, color='purple', alpha=0.9)\nax.text(5.2, 4, 1.4, 'Via', fontsize=9)\n\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Height')\nax.set_title('Metal Layer Stackup (Simplified)', fontsize=12)\nax.view_init(elev=20, azim=-60)\n\nplt.tight_layout()\nplt.show()\n</pre> # Visualize metal stackup fig = plt.figure(figsize=(12, 6)) ax = fig.add_subplot(111, projection='3d')  # Colors for each layer colors = ['#8B4513', '#808080', '#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#E91E63'] labels = ['Substrate', 'Poly', 'M1', 'M2', 'M3', 'M4', 'M5'] heights = [0, 0.5, 1.0, 1.8, 2.6, 3.4, 4.2] thicknesses = [0.4, 0.1, 0.3, 0.4, 0.4, 0.5, 0.6]  for i, (color, label, z, thick) in enumerate(zip(colors, labels, heights, thicknesses)):     # Draw each layer as a semi-transparent box     if i == 0:  # Substrate - full         xx, yy = np.meshgrid([0, 10], [0, 10])         ax.plot_surface(xx, yy, np.ones_like(xx) * z, alpha=0.7, color=color)     else:  # Metal layers - partial for visibility         # Horizontal stripe         xx, yy = np.meshgrid([1, 9], [4 + i*0.3, 6 - i*0.3])         ax.plot_surface(xx, yy, np.ones_like(xx) * z, alpha=0.8, color=color)          ax.text(11, 5, z + thick/2, label, fontsize=10)  # Add via between M1 and M2 ax.bar3d(5, 5, 1.0, 0.5, 0.5, 0.8, color='purple', alpha=0.9) ax.text(5.2, 4, 1.4, 'Via', fontsize=9)  ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Height') ax.set_title('Metal Layer Stackup (Simplified)', fontsize=12) ax.view_init(elev=20, azim=-60)  plt.tight_layout() plt.show() <p></p> In\u00a0[3]: Copied! <pre># Visualize on-chip passive components\nfig, axes = plt.subplots(1, 3, figsize=(15, 4))\n\n# Resistor (poly snake)\nax = axes[0]\nfor i in range(5):\n    y = i * 0.8\n    if i % 2 == 0:\n        ax.add_patch(patches.Rectangle((0.5, y), 4, 0.3, facecolor='#4CAF50', edgecolor='black'))\n    else:\n        ax.add_patch(patches.Rectangle((0.5, y), 4, 0.3, facecolor='#4CAF50', edgecolor='black'))\n    if i &lt; 4:\n        x_conn = 4.5 if i % 2 == 0 else 0.5\n        ax.add_patch(patches.Rectangle((x_conn - 0.15, y + 0.3), 0.3, 0.5, facecolor='#4CAF50', edgecolor='black'))\nax.set_xlim(0, 5.5)\nax.set_ylim(-0.5, 4.5)\nax.set_title('Poly Resistor\\n(snake pattern)', fontsize=11)\nax.set_aspect('equal')\nax.axis('off')\n\n# Capacitor (MOM - interdigitated)\nax = axes[1]\nfor i in range(6):\n    x = i * 0.7 + 0.3\n    if i % 2 == 0:\n        ax.add_patch(patches.Rectangle((x, 0), 0.25, 3.5, facecolor='#2196F3', edgecolor='black'))\n    else:\n        ax.add_patch(patches.Rectangle((x, 0.5), 0.25, 3.5, facecolor='#FF9800', edgecolor='black'))\n# Bus bars\nax.add_patch(patches.Rectangle((0.3, -0.3), 3.85, 0.25, facecolor='#2196F3', edgecolor='black'))\nax.add_patch(patches.Rectangle((0.3, 4.0), 3.85, 0.25, facecolor='#FF9800', edgecolor='black'))\nax.set_xlim(0, 5)\nax.set_ylim(-0.8, 4.8)\nax.set_title('MOM Capacitor\\n(interdigitated)', fontsize=11)\nax.set_aspect('equal')\nax.axis('off')\n\n# Inductor (spiral)\nax = axes[2]\ntheta = np.linspace(0, 6*np.pi, 200)\nr = 0.3 + 0.15 * theta / np.pi\nx = 2.5 + r * np.cos(theta)\ny = 2.5 + r * np.sin(theta)\nax.plot(x, y, 'b-', linewidth=3, color='#9C27B0')\nax.set_xlim(0, 5)\nax.set_ylim(0, 5)\nax.set_title('Spiral Inductor\\n(top metal)', fontsize=11)\nax.set_aspect('equal')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Visualize on-chip passive components fig, axes = plt.subplots(1, 3, figsize=(15, 4))  # Resistor (poly snake) ax = axes[0] for i in range(5):     y = i * 0.8     if i % 2 == 0:         ax.add_patch(patches.Rectangle((0.5, y), 4, 0.3, facecolor='#4CAF50', edgecolor='black'))     else:         ax.add_patch(patches.Rectangle((0.5, y), 4, 0.3, facecolor='#4CAF50', edgecolor='black'))     if i &lt; 4:         x_conn = 4.5 if i % 2 == 0 else 0.5         ax.add_patch(patches.Rectangle((x_conn - 0.15, y + 0.3), 0.3, 0.5, facecolor='#4CAF50', edgecolor='black')) ax.set_xlim(0, 5.5) ax.set_ylim(-0.5, 4.5) ax.set_title('Poly Resistor\\n(snake pattern)', fontsize=11) ax.set_aspect('equal') ax.axis('off')  # Capacitor (MOM - interdigitated) ax = axes[1] for i in range(6):     x = i * 0.7 + 0.3     if i % 2 == 0:         ax.add_patch(patches.Rectangle((x, 0), 0.25, 3.5, facecolor='#2196F3', edgecolor='black'))     else:         ax.add_patch(patches.Rectangle((x, 0.5), 0.25, 3.5, facecolor='#FF9800', edgecolor='black')) # Bus bars ax.add_patch(patches.Rectangle((0.3, -0.3), 3.85, 0.25, facecolor='#2196F3', edgecolor='black')) ax.add_patch(patches.Rectangle((0.3, 4.0), 3.85, 0.25, facecolor='#FF9800', edgecolor='black')) ax.set_xlim(0, 5) ax.set_ylim(-0.8, 4.8) ax.set_title('MOM Capacitor\\n(interdigitated)', fontsize=11) ax.set_aspect('equal') ax.axis('off')  # Inductor (spiral) ax = axes[2] theta = np.linspace(0, 6*np.pi, 200) r = 0.3 + 0.15 * theta / np.pi x = 2.5 + r * np.cos(theta) y = 2.5 + r * np.sin(theta) ax.plot(x, y, 'b-', linewidth=3, color='#9C27B0') ax.set_xlim(0, 5) ax.set_ylim(0, 5) ax.set_title('Spiral Inductor\\n(top metal)', fontsize=11) ax.set_aspect('equal') ax.axis('off')  plt.tight_layout() plt.show() <pre>/var/folders/vm/wfyvlqcx1nbcc7l_yn0sgjtm0000gn/T/ipykernel_27754/749521973.py:44: UserWarning: color is redundantly defined by the 'color' keyword argument and the fmt string \"b-\" (-&gt; color='b'). The keyword argument will take precedence.\n  ax.plot(x, y, 'b-', linewidth=3, color='#9C27B0')\n</pre> <p></p> <p>The MOSFET (Metal-Oxide-Semiconductor Field-Effect Transistor) is the building block of all digital circuits.</p> In\u00a0[4]: Copied! <pre># MOSFET cross-section\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n\ndef draw_mosfet(ax, nmos=True):\n    # Substrate\n    sub_color = '#FFE0B2' if nmos else '#E3F2FD'  # p-type or n-type\n    ax.add_patch(patches.Rectangle((0, 0), 10, 2, facecolor=sub_color, edgecolor='black'))\n    ax.text(5, 0.3, 'P-substrate' if nmos else 'N-well', ha='center', fontsize=10)\n    \n    # Source and Drain regions\n    sd_color = '#E3F2FD' if nmos else '#FFE0B2'  # n+ or p+\n    ax.add_patch(patches.Rectangle((1, 1.5), 2, 1, facecolor=sd_color, edgecolor='black'))\n    ax.add_patch(patches.Rectangle((7, 1.5), 2, 1, facecolor=sd_color, edgecolor='black'))\n    ax.text(2, 2, 'n+' if nmos else 'p+', ha='center', va='center', fontsize=10, fontweight='bold')\n    ax.text(8, 2, 'n+' if nmos else 'p+', ha='center', va='center', fontsize=10, fontweight='bold')\n    \n    # Gate oxide\n    ax.add_patch(patches.Rectangle((3.5, 2.5), 3, 0.2, facecolor='#90CAF9', edgecolor='black'))\n    ax.text(5, 2.6, 'oxide', ha='center', va='center', fontsize=8)\n    \n    # Gate\n    ax.add_patch(patches.Rectangle((3.5, 2.7), 3, 0.8, facecolor='#F44336', edgecolor='black'))\n    ax.text(5, 3.1, 'Gate', ha='center', va='center', fontsize=10, color='white', fontweight='bold')\n    \n    # Labels\n    ax.text(2, 3.5, 'Source', ha='center', fontsize=10)\n    ax.text(8, 3.5, 'Drain', ha='center', fontsize=10)\n    \n    # Metal contacts\n    ax.add_patch(patches.Rectangle((1.7, 2.5), 0.6, 1, facecolor='#9E9E9E', edgecolor='black'))\n    ax.add_patch(patches.Rectangle((7.7, 2.5), 0.6, 1, facecolor='#9E9E9E', edgecolor='black'))\n    \n    ax.set_xlim(-0.5, 10.5)\n    ax.set_ylim(-0.5, 4.5)\n    ax.set_aspect('equal')\n    ax.axis('off')\n    ax.set_title('NMOS Transistor' if nmos else 'PMOS Transistor', fontsize=12, fontweight='bold')\n\ndraw_mosfet(ax1, nmos=True)\ndraw_mosfet(ax2, nmos=False)\n\nplt.tight_layout()\nplt.show()\n</pre> # MOSFET cross-section fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))  def draw_mosfet(ax, nmos=True):     # Substrate     sub_color = '#FFE0B2' if nmos else '#E3F2FD'  # p-type or n-type     ax.add_patch(patches.Rectangle((0, 0), 10, 2, facecolor=sub_color, edgecolor='black'))     ax.text(5, 0.3, 'P-substrate' if nmos else 'N-well', ha='center', fontsize=10)          # Source and Drain regions     sd_color = '#E3F2FD' if nmos else '#FFE0B2'  # n+ or p+     ax.add_patch(patches.Rectangle((1, 1.5), 2, 1, facecolor=sd_color, edgecolor='black'))     ax.add_patch(patches.Rectangle((7, 1.5), 2, 1, facecolor=sd_color, edgecolor='black'))     ax.text(2, 2, 'n+' if nmos else 'p+', ha='center', va='center', fontsize=10, fontweight='bold')     ax.text(8, 2, 'n+' if nmos else 'p+', ha='center', va='center', fontsize=10, fontweight='bold')          # Gate oxide     ax.add_patch(patches.Rectangle((3.5, 2.5), 3, 0.2, facecolor='#90CAF9', edgecolor='black'))     ax.text(5, 2.6, 'oxide', ha='center', va='center', fontsize=8)          # Gate     ax.add_patch(patches.Rectangle((3.5, 2.7), 3, 0.8, facecolor='#F44336', edgecolor='black'))     ax.text(5, 3.1, 'Gate', ha='center', va='center', fontsize=10, color='white', fontweight='bold')          # Labels     ax.text(2, 3.5, 'Source', ha='center', fontsize=10)     ax.text(8, 3.5, 'Drain', ha='center', fontsize=10)          # Metal contacts     ax.add_patch(patches.Rectangle((1.7, 2.5), 0.6, 1, facecolor='#9E9E9E', edgecolor='black'))     ax.add_patch(patches.Rectangle((7.7, 2.5), 0.6, 1, facecolor='#9E9E9E', edgecolor='black'))          ax.set_xlim(-0.5, 10.5)     ax.set_ylim(-0.5, 4.5)     ax.set_aspect('equal')     ax.axis('off')     ax.set_title('NMOS Transistor' if nmos else 'PMOS Transistor', fontsize=12, fontweight='bold')  draw_mosfet(ax1, nmos=True) draw_mosfet(ax2, nmos=False)  plt.tight_layout() plt.show() <p></p> <p>In digital circuits, we use transistors as switches:</p> In\u00a0[5]: Copied! <pre># Inverter truth table and transfer curve\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\n# Transfer curve\nvin = np.linspace(0, 1.8, 100)\n# Simplified tanh model for inverter\nvout = 1.8 * (1 - np.tanh(8 * (vin - 0.9))) / 2\n\nax1.plot(vin, vout, 'b-', linewidth=2)\nax1.axhline(y=0.9, color='gray', linestyle='--', alpha=0.5)\nax1.axvline(x=0.9, color='gray', linestyle='--', alpha=0.5)\nax1.fill_between([0, 0.6], [1.8, 1.8], alpha=0.2, color='green', label='Input LOW')\nax1.fill_between([1.2, 1.8], [0, 0], [1.8, 1.8], alpha=0.2, color='red', label='Input HIGH')\nax1.set_xlabel('Vin (V)', fontsize=11)\nax1.set_ylabel('Vout (V)', fontsize=11)\nax1.set_title('Inverter Transfer Curve', fontsize=12)\nax1.set_xlim(0, 1.8)\nax1.set_ylim(0, 1.8)\nax1.grid(True, alpha=0.3)\nax1.legend()\n\n# Timing diagram\nt = np.linspace(0, 10, 1000)\nvin_signal = 0.9 + 0.9 * np.sign(np.sin(2 * np.pi * t / 5))\n# Simple RC delay model\nvout_signal = np.zeros_like(t)\ntau = 0.2\nfor i in range(1, len(t)):\n    target = 1.8 if vin_signal[i] &lt; 0.9 else 0\n    dt = t[i] - t[i-1]\n    vout_signal[i] = vout_signal[i-1] + (target - vout_signal[i-1]) * (1 - np.exp(-dt/tau))\n\nax2.plot(t, vin_signal, 'b-', linewidth=2, label='Input')\nax2.plot(t, vout_signal, 'r-', linewidth=2, label='Output')\nax2.set_xlabel('Time', fontsize=11)\nax2.set_ylabel('Voltage (V)', fontsize=11)\nax2.set_title('Inverter Timing', fontsize=12)\nax2.set_xlim(0, 10)\nax2.set_ylim(-0.2, 2.0)\nax2.legend()\nax2.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</pre> # Inverter truth table and transfer curve fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))  # Transfer curve vin = np.linspace(0, 1.8, 100) # Simplified tanh model for inverter vout = 1.8 * (1 - np.tanh(8 * (vin - 0.9))) / 2  ax1.plot(vin, vout, 'b-', linewidth=2) ax1.axhline(y=0.9, color='gray', linestyle='--', alpha=0.5) ax1.axvline(x=0.9, color='gray', linestyle='--', alpha=0.5) ax1.fill_between([0, 0.6], [1.8, 1.8], alpha=0.2, color='green', label='Input LOW') ax1.fill_between([1.2, 1.8], [0, 0], [1.8, 1.8], alpha=0.2, color='red', label='Input HIGH') ax1.set_xlabel('Vin (V)', fontsize=11) ax1.set_ylabel('Vout (V)', fontsize=11) ax1.set_title('Inverter Transfer Curve', fontsize=12) ax1.set_xlim(0, 1.8) ax1.set_ylim(0, 1.8) ax1.grid(True, alpha=0.3) ax1.legend()  # Timing diagram t = np.linspace(0, 10, 1000) vin_signal = 0.9 + 0.9 * np.sign(np.sin(2 * np.pi * t / 5)) # Simple RC delay model vout_signal = np.zeros_like(t) tau = 0.2 for i in range(1, len(t)):     target = 1.8 if vin_signal[i] &lt; 0.9 else 0     dt = t[i] - t[i-1]     vout_signal[i] = vout_signal[i-1] + (target - vout_signal[i-1]) * (1 - np.exp(-dt/tau))  ax2.plot(t, vin_signal, 'b-', linewidth=2, label='Input') ax2.plot(t, vout_signal, 'r-', linewidth=2, label='Output') ax2.set_xlabel('Time', fontsize=11) ax2.set_ylabel('Voltage (V)', fontsize=11) ax2.set_title('Inverter Timing', fontsize=12) ax2.set_xlim(0, 10) ax2.set_ylim(-0.2, 2.0) ax2.legend() ax2.grid(True, alpha=0.3)  plt.tight_layout() plt.show() <p></p> <p>In analog circuits, transistors operate in the saturation region to amplify signals.</p> In\u00a0[6]: Copied! <pre># MOSFET I-V characteristics\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\n# Parameters\nVth = 0.4  # Threshold voltage\nk = 0.5    # Transconductance parameter\n\n# Output characteristics (Id vs Vds for different Vgs)\nVds = np.linspace(0, 1.8, 100)\nfor Vgs in [0.6, 0.8, 1.0, 1.2, 1.4]:\n    Id = np.zeros_like(Vds)\n    for i, vds in enumerate(Vds):\n        if Vgs &lt;= Vth:\n            Id[i] = 0  # Cutoff\n        elif vds &lt; Vgs - Vth:\n            Id[i] = k * ((Vgs - Vth) * vds - 0.5 * vds**2)  # Linear\n        else:\n            Id[i] = 0.5 * k * (Vgs - Vth)**2  # Saturation\n    ax1.plot(Vds, Id * 1000, label=f'Vgs = {Vgs}V')\n\nax1.set_xlabel('Vds (V)', fontsize=11)\nax1.set_ylabel('Id (mA)', fontsize=11)\nax1.set_title('Output Characteristics', fontsize=12)\nax1.legend(loc='right')\nax1.grid(True, alpha=0.3)\nax1.set_xlim(0, 1.8)\n\n# Mark regions\nax1.axvline(x=0.6, color='gray', linestyle=':', alpha=0.5)\nax1.text(0.3, 0.5, 'Linear', fontsize=9, ha='center')\nax1.text(1.2, 0.5, 'Saturation', fontsize=9, ha='center')\n\n# Transfer characteristic (Id vs Vgs)\nVgs = np.linspace(0, 1.8, 100)\nId = np.maximum(0, 0.5 * k * (Vgs - Vth)**2)\nId[Vgs &lt; Vth] = 0\n\nax2.plot(Vgs, Id * 1000, 'b-', linewidth=2)\nax2.axvline(x=Vth, color='red', linestyle='--', label=f'Vth = {Vth}V')\nax2.set_xlabel('Vgs (V)', fontsize=11)\nax2.set_ylabel('Id (mA)', fontsize=11)\nax2.set_title('Transfer Characteristic', fontsize=12)\nax2.legend()\nax2.grid(True, alpha=0.3)\nax2.set_xlim(0, 1.8)\n\nplt.tight_layout()\nplt.show()\n</pre> # MOSFET I-V characteristics fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))  # Parameters Vth = 0.4  # Threshold voltage k = 0.5    # Transconductance parameter  # Output characteristics (Id vs Vds for different Vgs) Vds = np.linspace(0, 1.8, 100) for Vgs in [0.6, 0.8, 1.0, 1.2, 1.4]:     Id = np.zeros_like(Vds)     for i, vds in enumerate(Vds):         if Vgs &lt;= Vth:             Id[i] = 0  # Cutoff         elif vds &lt; Vgs - Vth:             Id[i] = k * ((Vgs - Vth) * vds - 0.5 * vds**2)  # Linear         else:             Id[i] = 0.5 * k * (Vgs - Vth)**2  # Saturation     ax1.plot(Vds, Id * 1000, label=f'Vgs = {Vgs}V')  ax1.set_xlabel('Vds (V)', fontsize=11) ax1.set_ylabel('Id (mA)', fontsize=11) ax1.set_title('Output Characteristics', fontsize=12) ax1.legend(loc='right') ax1.grid(True, alpha=0.3) ax1.set_xlim(0, 1.8)  # Mark regions ax1.axvline(x=0.6, color='gray', linestyle=':', alpha=0.5) ax1.text(0.3, 0.5, 'Linear', fontsize=9, ha='center') ax1.text(1.2, 0.5, 'Saturation', fontsize=9, ha='center')  # Transfer characteristic (Id vs Vgs) Vgs = np.linspace(0, 1.8, 100) Id = np.maximum(0, 0.5 * k * (Vgs - Vth)**2) Id[Vgs &lt; Vth] = 0  ax2.plot(Vgs, Id * 1000, 'b-', linewidth=2) ax2.axvline(x=Vth, color='red', linestyle='--', label=f'Vth = {Vth}V') ax2.set_xlabel('Vgs (V)', fontsize=11) ax2.set_ylabel('Id (mA)', fontsize=11) ax2.set_title('Transfer Characteristic', fontsize=12) ax2.legend() ax2.grid(True, alpha=0.3) ax2.set_xlim(0, 1.8)  plt.tight_layout() plt.show() <p></p> <p></p> <p></p> In\u00a0[7]: Copied! <pre># H-tree clock distribution\nfig, ax = plt.subplots(figsize=(8, 8))\n\ndef draw_h_tree(ax, x, y, size, depth):\n    if depth == 0:\n        ax.plot(x, y, 'ro', markersize=8)  # Flip-flop\n        return\n    \n    # Horizontal line\n    ax.plot([x - size/2, x + size/2], [y, y], 'b-', linewidth=2)\n    \n    # Vertical lines at ends\n    ax.plot([x - size/2, x - size/2], [y - size/2, y + size/2], 'b-', linewidth=2)\n    ax.plot([x + size/2, x + size/2], [y - size/2, y + size/2], 'b-', linewidth=2)\n    \n    # Recurse\n    draw_h_tree(ax, x - size/2, y + size/2, size/2, depth - 1)\n    draw_h_tree(ax, x - size/2, y - size/2, size/2, depth - 1)\n    draw_h_tree(ax, x + size/2, y + size/2, size/2, depth - 1)\n    draw_h_tree(ax, x + size/2, y - size/2, size/2, depth - 1)\n\n# Draw from center\nax.plot(0, 0, 'g^', markersize=15, label='Clock source')\nax.plot([0, 0], [0, 2], 'b-', linewidth=3)\ndraw_h_tree(ax, 0, 2, 2, 3)\n\nax.set_xlim(-3, 3)\nax.set_ylim(-1.5, 4)\nax.set_aspect('equal')\nax.set_title('H-Tree Clock Distribution', fontsize=12)\nax.legend(loc='lower right')\nax.grid(True, alpha=0.3)\n\n# Add explanation\nax.text(2, -1, 'Red dots = flip-flops\\n(equal distance from source)', fontsize=9)\n\nplt.tight_layout()\nplt.show()\n</pre> # H-tree clock distribution fig, ax = plt.subplots(figsize=(8, 8))  def draw_h_tree(ax, x, y, size, depth):     if depth == 0:         ax.plot(x, y, 'ro', markersize=8)  # Flip-flop         return          # Horizontal line     ax.plot([x - size/2, x + size/2], [y, y], 'b-', linewidth=2)          # Vertical lines at ends     ax.plot([x - size/2, x - size/2], [y - size/2, y + size/2], 'b-', linewidth=2)     ax.plot([x + size/2, x + size/2], [y - size/2, y + size/2], 'b-', linewidth=2)          # Recurse     draw_h_tree(ax, x - size/2, y + size/2, size/2, depth - 1)     draw_h_tree(ax, x - size/2, y - size/2, size/2, depth - 1)     draw_h_tree(ax, x + size/2, y + size/2, size/2, depth - 1)     draw_h_tree(ax, x + size/2, y - size/2, size/2, depth - 1)  # Draw from center ax.plot(0, 0, 'g^', markersize=15, label='Clock source') ax.plot([0, 0], [0, 2], 'b-', linewidth=3) draw_h_tree(ax, 0, 2, 2, 3)  ax.set_xlim(-3, 3) ax.set_ylim(-1.5, 4) ax.set_aspect('equal') ax.set_title('H-Tree Clock Distribution', fontsize=12) ax.legend(loc='lower right') ax.grid(True, alpha=0.3)  # Add explanation ax.text(2, -1, 'Red dots = flip-flops\\n(equal distance from source)', fontsize=9)  plt.tight_layout() plt.show()"},{"location":"notebooks/02_analog_basics/#contents","title":"Contents\u00b6","text":"<ol> <li>Wires &amp; Interconnect</li> <li>Passive Components</li> <li>The MOSFET Transistor</li> <li>Transistors as Switches</li> <li>Transistors as Amplifiers</li> <li>Device Models</li> <li>Power Distribution</li> <li>Clock Distribution</li> </ol>"},{"location":"notebooks/02_analog_basics/#1-wires-interconnect","title":"1. Wires &amp; Interconnect\u00b6","text":""},{"location":"notebooks/02_analog_basics/#metal-layers","title":"Metal Layers\u00b6","text":"<p>Modern chips have multiple metal layers stacked on top of each other:</p> Layer Typical Use Characteristics M1 (lowest) Local connections Thinnest, highest resistance M2-M4 Intermediate routing Medium thickness Top metals Power, clock, long routes Thickest, lowest resistance"},{"location":"notebooks/02_analog_basics/#why-multiple-layers","title":"Why Multiple Layers?\u00b6","text":"<ul> <li>Wires can cross over each other on different layers</li> <li>Vias connect between layers</li> <li>More routing resources = denser designs</li> </ul>"},{"location":"notebooks/02_analog_basics/#wire-properties","title":"Wire Properties\u00b6","text":"<p>Every wire has:</p> Property Symbol Effect Resistance R Voltage drop, power loss, delay Capacitance C Delay, power consumption Inductance L Important at high frequencies <p>The RC delay of a wire determines how fast signals can travel:</p> <p>$$\\tau = R \\times C$$</p>"},{"location":"notebooks/02_analog_basics/#2-passive-components","title":"2. Passive Components\u00b6","text":""},{"location":"notebooks/02_analog_basics/#resistors","title":"Resistors\u00b6","text":"<p>On-chip resistors can be made from:</p> <ul> <li>Polysilicon (poly resistors)</li> <li>Diffusion (in the substrate)</li> <li>Metal (usually for small values)</li> </ul> <p>Sheet resistance ($R_\\square$): resistance of a square of material</p> <p>$$R = R_\\square \\times \\frac{L}{W}$$</p>"},{"location":"notebooks/02_analog_basics/#capacitors","title":"Capacitors\u00b6","text":"<p>Types available on-chip:</p> <ul> <li>MOM (Metal-Oxide-Metal): interdigitated metal fingers</li> <li>MIM (Metal-Insulator-Metal): parallel plates</li> <li>MOS (gate capacitor): transistor used as capacitor</li> </ul>"},{"location":"notebooks/02_analog_basics/#inductors","title":"Inductors\u00b6","text":"<ul> <li>Made from spiral metal traces</li> <li>Large area, used mainly in RF designs</li> <li>Quality factor (Q) limited by metal resistance</li> </ul>"},{"location":"notebooks/02_analog_basics/#3-the-mosfet-transistor","title":"3. The MOSFET Transistor\u00b6","text":""},{"location":"notebooks/02_analog_basics/#structure","title":"Structure\u00b6","text":"<pre><code>        Gate (G)\n           \u2502\n      \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500   \u2190 Gate oxide (very thin insulator)\n     \u2502           \u2502\n  Source (S)  Drain (D)\n     \u2502    \u2500\u2500\u2500    \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2190 Channel region\n         Body\n</code></pre>"},{"location":"notebooks/02_analog_basics/#two-types","title":"Two Types\u00b6","text":"Type Symbol Turns ON when Used for NMOS Gate = HIGH Gate voltage &gt; threshold Pull-down (connect to GND) PMOS Gate = LOW Gate voltage &lt; (VDD - threshold) Pull-up (connect to VDD)"},{"location":"notebooks/02_analog_basics/#4-transistors-as-switches","title":"4. Transistors as Switches\u00b6","text":""},{"location":"notebooks/02_analog_basics/#cmos-inverter","title":"CMOS Inverter\u00b6","text":"<p>The simplest logic gate - combines PMOS and NMOS:</p> <pre><code>        VDD\n         \u2502\n       \u250c\u2500\u2534\u2500\u2510\n   \u2500\u2500\u2500\u2500\u2524 P \u251c\u2500\u2500\u252c\u2500\u2500 Output\n       \u2514\u2500\u2500\u2500\u2518  \u2502\n   Input      \u2502\n       \u250c\u2500\u2500\u2500\u2510  \u2502\n   \u2500\u2500\u2500\u2500\u2524 N \u251c\u2500\u2500\u2518\n       \u2514\u2500\u252c\u2500\u2518\n         \u2502\n        GND\n</code></pre> Input PMOS NMOS Output 0 (LOW) ON OFF 1 (HIGH) 1 (HIGH) OFF ON 0 (LOW)"},{"location":"notebooks/02_analog_basics/#building-other-gates","title":"Building Other Gates\u00b6","text":"<p>All logic gates are built from NMOS/PMOS combinations:</p> Gate NMOS PMOS NAND Series (both must be ON to pull low) Parallel (either pulls high) NOR Parallel (either pulls low) Series (both must be ON to pull high)"},{"location":"notebooks/02_analog_basics/#5-transistors-as-amplifiers","title":"5. Transistors as Amplifiers\u00b6","text":""},{"location":"notebooks/02_analog_basics/#regions-of-operation","title":"Regions of Operation\u00b6","text":"Region Condition Behavior Cutoff Vgs &lt; Vth No current (OFF) Linear/Triode Vgs &gt; Vth, Vds &lt; Vgs-Vth Acts like a resistor Saturation Vgs &gt; Vth, Vds &gt; Vgs-Vth Current controlled by Vgs (amplifier)"},{"location":"notebooks/02_analog_basics/#key-parameter-transconductance-gm","title":"Key Parameter: Transconductance (gm)\u00b6","text":"<p>$$g_m = \\frac{\\partial I_D}{\\partial V_{GS}}$$</p> <p>This tells us how much the output current changes for a small change in gate voltage - the \"gain\" of the transistor.</p> <p>Note on threshold voltage: The plots below use Vth = 0.4V for illustration. Actual Sky130 PDK transistors have different thresholds depending on flavor: standard (svt) ~0.5V, low-Vth (lvt) ~0.35V, high-Vth (hvt) ~0.65V. Real devices also exhibit short-channel effects (threshold roll-off, DIBL) not captured in this simple square-law model.</p>"},{"location":"notebooks/02_analog_basics/#6-device-models","title":"6. Device Models\u00b6","text":""},{"location":"notebooks/02_analog_basics/#spice-models","title":"SPICE Models\u00b6","text":"<p>To simulate circuits, we need mathematical models of transistors. SPICE uses hierarchical model levels:</p> Level Complexity Use Case Level 1 Simple square-law Quick estimates Level 3 Short-channel effects Legacy BSIM3/4 Industry standard Accurate analog PSP Surface-potential based Advanced modeling"},{"location":"notebooks/02_analog_basics/#model-parameters","title":"Model Parameters\u00b6","text":"<p>Key parameters you'll see:</p> Parameter Meaning VTH0 Threshold voltage TOX Gate oxide thickness U0 Mobility VSAT Saturation velocity"},{"location":"notebooks/02_analog_basics/#7-power-distribution","title":"7. Power Distribution\u00b6","text":""},{"location":"notebooks/02_analog_basics/#power-grid","title":"Power Grid\u00b6","text":"<p>Getting power to all transistors requires a power grid:</p> <ul> <li>VDD (positive supply) and GND rails</li> <li>Uses wide metal traces on upper layers</li> <li>Multiple vias to reduce resistance</li> </ul>"},{"location":"notebooks/02_analog_basics/#ir-drop","title":"IR Drop\u00b6","text":"<p>Current flowing through resistive wires causes voltage drop:</p> <p>$$\\Delta V = I \\times R$$</p> <p>This means transistors far from power pads see lower voltage \u2192 slower operation.</p>"},{"location":"notebooks/02_analog_basics/#decoupling-capacitors","title":"Decoupling Capacitors\u00b6","text":"<p>Placed near transistors to:</p> <ul> <li>Supply instantaneous current during switching</li> <li>Filter power supply noise</li> </ul>"},{"location":"notebooks/02_analog_basics/#8-clock-distribution","title":"8. Clock Distribution\u00b6","text":""},{"location":"notebooks/02_analog_basics/#the-challenge","title":"The Challenge\u00b6","text":"<p>All flip-flops need to receive the clock at (nearly) the same time.</p> <p>Clock skew: difference in clock arrival time between two flip-flops</p> <p>If skew is too large \u2192 timing failures!</p>"},{"location":"notebooks/02_analog_basics/#solutions","title":"Solutions\u00b6","text":"Approach Description H-tree Balanced binary tree structure Clock mesh Grid of clock wires, shorted together Clock buffers Amplify and balance clock signals"},{"location":"notebooks/02_analog_basics/#summary","title":"Summary\u00b6","text":"<ul> <li>Wires have R, C, and L that affect signal propagation</li> <li>MOSFETs are the fundamental building block</li> <li>In digital circuits, transistors act as switches</li> <li>In analog circuits, transistors act as amplifiers</li> <li>Power and clock distribution are critical for large designs</li> </ul>"},{"location":"notebooks/02_analog_basics/#homework","title":"Homework\u00b6","text":"<ol> <li>Simulate a PDK inverter in SPICE</li> <li>Measure delay from input to output</li> <li>Sweep input slew rate - how does it affect delay?</li> </ol>"},{"location":"notebooks/03_schematic_simulation/","title":"Schematic Design & Simulation","text":"Schematic Design &amp; Simulation <p>Week 2, Session 1 \u2014 Fab Futures</p> In\u00a0[1]: Copied! <pre># Setup\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import FancyBboxPatch, Circle, Rectangle\nimport numpy as np\n\nprint(\"Setup complete.\")\n</pre> # Setup import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.patches import FancyBboxPatch, Circle, Rectangle import numpy as np  print(\"Setup complete.\") <pre>Setup complete.\n</pre> <p></p> In\u00a0[2]: Copied! <pre># Simple schematic: Inverter\nfig, ax = plt.subplots(figsize=(10, 8))\n\n# VDD rail\nax.plot([5, 5], [7, 6.5], 'k-', linewidth=2)\nax.plot([4.5, 5.5], [7, 7], 'k-', linewidth=3)\nax.text(5, 7.3, 'VDD', ha='center', fontsize=11, fontweight='bold')\n\n# PMOS (circle on gate)\nax.add_patch(Rectangle((4, 5), 2, 1.5, fill=False, edgecolor='blue', linewidth=2))\nax.text(5, 5.75, 'PMOS', ha='center', va='center', fontsize=10, color='blue')\nax.add_patch(Circle((3.8, 5.75), 0.15, fill=False, edgecolor='blue', linewidth=2))\n\n# PMOS connections\nax.plot([5, 5], [6.5, 6.5], 'k-', linewidth=2)  # drain to VDD\nax.plot([5, 5], [5, 4], 'k-', linewidth=2)  # source to output\nax.plot([3.5, 3.65], [5.75, 5.75], 'k-', linewidth=2)  # gate\n\n# NMOS\nax.add_patch(Rectangle((4, 2), 2, 1.5, fill=False, edgecolor='red', linewidth=2))\nax.text(5, 2.75, 'NMOS', ha='center', va='center', fontsize=10, color='red')\n\n# NMOS connections\nax.plot([5, 5], [3.5, 4], 'k-', linewidth=2)  # drain to output\nax.plot([5, 5], [2, 1.5], 'k-', linewidth=2)  # source to GND\nax.plot([3.5, 4], [2.75, 2.75], 'k-', linewidth=2)  # gate\n\n# Connect gates\nax.plot([3.5, 3.5], [2.75, 5.75], 'k-', linewidth=2)\nax.plot([1.5, 3.5], [4.25, 4.25], 'k-', linewidth=2)  # input\nax.plot([3.5, 3.5], [4.25, 4.25], 'ko', markersize=6)  # junction dot\n\n# Output\nax.plot([5, 7], [4, 4], 'k-', linewidth=2)\nax.plot([5, 5], [4, 4], 'ko', markersize=6)  # junction dot\n\n# GND symbol\nax.plot([5, 5], [1.5, 1.2], 'k-', linewidth=2)\nax.plot([4.5, 5.5], [1.2, 1.2], 'k-', linewidth=2)\nax.plot([4.65, 5.35], [1.0, 1.0], 'k-', linewidth=2)\nax.plot([4.8, 5.2], [0.8, 0.8], 'k-', linewidth=2)\nax.text(5, 0.4, 'GND', ha='center', fontsize=11)\n\n# Labels\nax.text(1.2, 4.25, 'IN', fontsize=12, fontweight='bold', va='center')\nax.text(7.3, 4, 'OUT', fontsize=12, fontweight='bold', va='center')\n\n# Input/output markers\nax.plot([1.5], [4.25], 'g&gt;', markersize=12)\nax.plot([7], [4], 'r&gt;', markersize=12)\n\nax.set_xlim(0, 9)\nax.set_ylim(0, 8)\nax.set_aspect('equal')\nax.set_title('CMOS Inverter Schematic', fontsize=14, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Simple schematic: Inverter fig, ax = plt.subplots(figsize=(10, 8))  # VDD rail ax.plot([5, 5], [7, 6.5], 'k-', linewidth=2) ax.plot([4.5, 5.5], [7, 7], 'k-', linewidth=3) ax.text(5, 7.3, 'VDD', ha='center', fontsize=11, fontweight='bold')  # PMOS (circle on gate) ax.add_patch(Rectangle((4, 5), 2, 1.5, fill=False, edgecolor='blue', linewidth=2)) ax.text(5, 5.75, 'PMOS', ha='center', va='center', fontsize=10, color='blue') ax.add_patch(Circle((3.8, 5.75), 0.15, fill=False, edgecolor='blue', linewidth=2))  # PMOS connections ax.plot([5, 5], [6.5, 6.5], 'k-', linewidth=2)  # drain to VDD ax.plot([5, 5], [5, 4], 'k-', linewidth=2)  # source to output ax.plot([3.5, 3.65], [5.75, 5.75], 'k-', linewidth=2)  # gate  # NMOS ax.add_patch(Rectangle((4, 2), 2, 1.5, fill=False, edgecolor='red', linewidth=2)) ax.text(5, 2.75, 'NMOS', ha='center', va='center', fontsize=10, color='red')  # NMOS connections ax.plot([5, 5], [3.5, 4], 'k-', linewidth=2)  # drain to output ax.plot([5, 5], [2, 1.5], 'k-', linewidth=2)  # source to GND ax.plot([3.5, 4], [2.75, 2.75], 'k-', linewidth=2)  # gate  # Connect gates ax.plot([3.5, 3.5], [2.75, 5.75], 'k-', linewidth=2) ax.plot([1.5, 3.5], [4.25, 4.25], 'k-', linewidth=2)  # input ax.plot([3.5, 3.5], [4.25, 4.25], 'ko', markersize=6)  # junction dot  # Output ax.plot([5, 7], [4, 4], 'k-', linewidth=2) ax.plot([5, 5], [4, 4], 'ko', markersize=6)  # junction dot  # GND symbol ax.plot([5, 5], [1.5, 1.2], 'k-', linewidth=2) ax.plot([4.5, 5.5], [1.2, 1.2], 'k-', linewidth=2) ax.plot([4.65, 5.35], [1.0, 1.0], 'k-', linewidth=2) ax.plot([4.8, 5.2], [0.8, 0.8], 'k-', linewidth=2) ax.text(5, 0.4, 'GND', ha='center', fontsize=11)  # Labels ax.text(1.2, 4.25, 'IN', fontsize=12, fontweight='bold', va='center') ax.text(7.3, 4, 'OUT', fontsize=12, fontweight='bold', va='center')  # Input/output markers ax.plot([1.5], [4.25], 'g&gt;', markersize=12) ax.plot([7], [4], 'r&gt;', markersize=12)  ax.set_xlim(0, 9) ax.set_ylim(0, 8) ax.set_aspect('equal') ax.set_title('CMOS Inverter Schematic', fontsize=14, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show() <p></p> <p></p> In\u00a0[3]: Copied! <pre># Demonstrate different analysis types\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# DC Sweep (inverter transfer curve)\nax = axes[0, 0]\nvin = np.linspace(0, 1.8, 100)\nvout = 1.8 / (1 + np.exp(10 * (vin - 0.9)))\nax.plot(vin, vout, 'b-', linewidth=2)\nax.set_xlabel('Vin (V)')\nax.set_ylabel('Vout (V)')\nax.set_title('.dc Analysis: Inverter Transfer Curve', fontsize=11)\nax.grid(True, alpha=0.3)\nax.set_xlim(0, 1.8)\nax.set_ylim(0, 1.8)\n\n# Transient (pulse response)\nax = axes[0, 1]\nt = np.linspace(0, 10, 1000)\nvin = 0.9 + 0.9 * np.sign(np.sin(2 * np.pi * t / 4))\n# Simulate RC delay\nvout = np.zeros_like(t)\ntau = 0.15\nfor i in range(1, len(t)):\n    target = 0 if vin[i] &gt; 0.9 else 1.8\n    dt = t[i] - t[i-1]\n    vout[i] = vout[i-1] + (target - vout[i-1]) * (1 - np.exp(-dt/tau))\nax.plot(t, vin, 'b-', linewidth=2, label='Vin')\nax.plot(t, vout, 'r-', linewidth=2, label='Vout')\nax.set_xlabel('Time (ns)')\nax.set_ylabel('Voltage (V)')\nax.set_title('.tran Analysis: Pulse Response', fontsize=11)\nax.legend()\nax.grid(True, alpha=0.3)\n\n# AC Analysis (Bode plot)\nax = axes[1, 0]\nfreq = np.logspace(3, 10, 100)  # 1kHz to 10GHz\n# Simple single-pole response\nf_3db = 1e8  # 100 MHz bandwidth\ngain_db = 20 - 20 * np.log10(np.sqrt(1 + (freq/f_3db)**2))\nax.semilogx(freq, gain_db, 'b-', linewidth=2)\nax.axhline(y=17, color='r', linestyle='--', alpha=0.5, label='-3dB point')\nax.axvline(x=f_3db, color='r', linestyle='--', alpha=0.5)\nax.set_xlabel('Frequency (Hz)')\nax.set_ylabel('Gain (dB)')\nax.set_title('.ac Analysis: Frequency Response', fontsize=11)\nax.grid(True, alpha=0.3, which='both')\nax.set_ylim(-20, 25)\n\n# Operating Point\nax = axes[1, 1]\nax.text(0.5, 0.8, 'Operating Point (.op)', ha='center', fontsize=14, fontweight='bold',\n        transform=ax.transAxes)\nop_text = \"\"\"\nNode Voltages:\n  V(vdd)  = 1.800 V\n  V(in)   = 0.900 V  \n  V(out)  = 0.892 V\n\nDevice Currents:\n  I(Mp)   = -15.2 \u00b5A\n  I(Mn)   =  15.2 \u00b5A\n\"\"\"\nax.text(0.5, 0.5, op_text, ha='center', va='center', fontsize=11,\n        family='monospace', transform=ax.transAxes,\n        bbox=dict(boxstyle='round', facecolor='lightyellow', edgecolor='gray'))\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Demonstrate different analysis types fig, axes = plt.subplots(2, 2, figsize=(12, 10))  # DC Sweep (inverter transfer curve) ax = axes[0, 0] vin = np.linspace(0, 1.8, 100) vout = 1.8 / (1 + np.exp(10 * (vin - 0.9))) ax.plot(vin, vout, 'b-', linewidth=2) ax.set_xlabel('Vin (V)') ax.set_ylabel('Vout (V)') ax.set_title('.dc Analysis: Inverter Transfer Curve', fontsize=11) ax.grid(True, alpha=0.3) ax.set_xlim(0, 1.8) ax.set_ylim(0, 1.8)  # Transient (pulse response) ax = axes[0, 1] t = np.linspace(0, 10, 1000) vin = 0.9 + 0.9 * np.sign(np.sin(2 * np.pi * t / 4)) # Simulate RC delay vout = np.zeros_like(t) tau = 0.15 for i in range(1, len(t)):     target = 0 if vin[i] &gt; 0.9 else 1.8     dt = t[i] - t[i-1]     vout[i] = vout[i-1] + (target - vout[i-1]) * (1 - np.exp(-dt/tau)) ax.plot(t, vin, 'b-', linewidth=2, label='Vin') ax.plot(t, vout, 'r-', linewidth=2, label='Vout') ax.set_xlabel('Time (ns)') ax.set_ylabel('Voltage (V)') ax.set_title('.tran Analysis: Pulse Response', fontsize=11) ax.legend() ax.grid(True, alpha=0.3)  # AC Analysis (Bode plot) ax = axes[1, 0] freq = np.logspace(3, 10, 100)  # 1kHz to 10GHz # Simple single-pole response f_3db = 1e8  # 100 MHz bandwidth gain_db = 20 - 20 * np.log10(np.sqrt(1 + (freq/f_3db)**2)) ax.semilogx(freq, gain_db, 'b-', linewidth=2) ax.axhline(y=17, color='r', linestyle='--', alpha=0.5, label='-3dB point') ax.axvline(x=f_3db, color='r', linestyle='--', alpha=0.5) ax.set_xlabel('Frequency (Hz)') ax.set_ylabel('Gain (dB)') ax.set_title('.ac Analysis: Frequency Response', fontsize=11) ax.grid(True, alpha=0.3, which='both') ax.set_ylim(-20, 25)  # Operating Point ax = axes[1, 1] ax.text(0.5, 0.8, 'Operating Point (.op)', ha='center', fontsize=14, fontweight='bold',         transform=ax.transAxes) op_text = \"\"\" Node Voltages:   V(vdd)  = 1.800 V   V(in)   = 0.900 V     V(out)  = 0.892 V  Device Currents:   I(Mp)   = -15.2 \u00b5A   I(Mn)   =  15.2 \u00b5A \"\"\" ax.text(0.5, 0.5, op_text, ha='center', va='center', fontsize=11,         family='monospace', transform=ax.transAxes,         bbox=dict(boxstyle='round', facecolor='lightyellow', edgecolor='gray')) ax.axis('off')  plt.tight_layout() plt.show() <p></p> <p></p> <p></p>"},{"location":"notebooks/03_schematic_simulation/#contents","title":"Contents\u00b6","text":"<ol> <li>Schematic Capture Basics</li> <li>SPICE Simulation</li> <li>Analysis Types</li> <li>Libraries and PDKs</li> <li>Behavioral Modeling</li> <li>Simulation Tips</li> </ol>"},{"location":"notebooks/03_schematic_simulation/#1-schematic-capture-basics","title":"1. Schematic Capture Basics\u00b6","text":""},{"location":"notebooks/03_schematic_simulation/#what-is-a-schematic","title":"What is a Schematic?\u00b6","text":"<p>A schematic is a graphical representation of a circuit using symbols for components and lines for wires.</p>"},{"location":"notebooks/03_schematic_simulation/#schematic-capture-tools","title":"Schematic Capture Tools\u00b6","text":"Tool Type Notes Xschem Open source Integrates with ngspice KiCad Open source Great for PCB design too Cadence Virtuoso Commercial Industry standard for IC"},{"location":"notebooks/03_schematic_simulation/#basic-schematic-elements","title":"Basic Schematic Elements\u00b6","text":"Element Symbol Purpose Wire Line Electrical connection Net label Text Names a wire (same name = connected) Instance Symbol A component (resistor, transistor, etc.) Port I/O marker Input/output of the circuit Ground GND symbol Reference voltage (0V)"},{"location":"notebooks/03_schematic_simulation/#2-spice-simulation","title":"2. SPICE Simulation\u00b6","text":""},{"location":"notebooks/03_schematic_simulation/#what-is-spice","title":"What is SPICE?\u00b6","text":"<p>SPICE (Simulation Program with Integrated Circuit Emphasis) is the industry standard for analog circuit simulation.</p>"},{"location":"notebooks/03_schematic_simulation/#spice-netlist-format","title":"SPICE Netlist Format\u00b6","text":"<pre>* Inverter circuit\n.include \"sky130.lib\"\n\n* Power supply\nVdd vdd gnd 1.8\n\n* Input signal (rise/fall times realistic for 130nm)\nVin in gnd PULSE(0 1.8 0 100p 100p 1n 2n)\n\n* PMOS: drain gate source body\nMp out in vdd vdd sky130_fd_pr__pfet_01v8 W=1u L=150n\n\n* NMOS: drain gate source body\nMn out in gnd gnd sky130_fd_pr__nfet_01v8 W=0.5u L=150n\n\n* Simulation commands\n.tran 10p 10n\n.end\n</pre>"},{"location":"notebooks/03_schematic_simulation/#netlist-elements","title":"Netlist Elements\u00b6","text":"First Letter Component R Resistor C Capacitor L Inductor V Voltage source I Current source M MOSFET X Subcircuit instance"},{"location":"notebooks/03_schematic_simulation/#3-analysis-types","title":"3. Analysis Types\u00b6","text":""},{"location":"notebooks/03_schematic_simulation/#common-spice-analyses","title":"Common SPICE Analyses\u00b6","text":"Analysis Command Purpose DC <code>.dc</code> Sweep DC voltage/current, find operating point AC <code>.ac</code> Frequency response (gain, phase) Transient <code>.tran</code> Time-domain response Operating Point <code>.op</code> DC node voltages and currents"},{"location":"notebooks/03_schematic_simulation/#4-libraries-and-pdks","title":"4. Libraries and PDKs\u00b6","text":""},{"location":"notebooks/03_schematic_simulation/#pdk-device-libraries","title":"PDK Device Libraries\u00b6","text":"<p>A PDK provides SPICE models for all available devices:</p> <p>SkyWater 130nm examples:</p> Device SPICE Model Name Description 1.8V NFET <code>sky130_fd_pr__nfet_01v8</code> Standard NMOS 1.8V PFET <code>sky130_fd_pr__pfet_01v8</code> Standard PMOS 3.3V NFET <code>sky130_fd_pr__nfet_03v3_nvt</code> I/O transistor Poly resistor <code>sky130_fd_pr__res_high_po</code> High-R poly MIM capacitor <code>sky130_fd_pr__cap_mim_m3_1</code> Metal capacitor"},{"location":"notebooks/03_schematic_simulation/#corner-models","title":"Corner Models\u00b6","text":"<p>Manufacturing varies! We simulate at multiple corners:</p> Corner NMOS PMOS Meaning TT Typical Typical Nominal process FF Fast Fast Best-case speed SS Slow Slow Worst-case speed SF Slow Fast Skewed FS Fast Slow Skewed"},{"location":"notebooks/03_schematic_simulation/#5-behavioral-modeling","title":"5. Behavioral Modeling\u00b6","text":""},{"location":"notebooks/03_schematic_simulation/#when-to-use-behavioral-models","title":"When to Use Behavioral Models\u00b6","text":"<p>Sometimes you don't need transistor-level detail:</p> <ul> <li>Early design exploration - get quick answers</li> <li>Mixed-signal simulation - analog blocks with digital</li> <li>Complex functions - ADCs, PLLs, etc.</li> </ul>"},{"location":"notebooks/03_schematic_simulation/#verilog-a-example","title":"Verilog-A Example\u00b6","text":"<pre>// Ideal voltage-controlled switch\nmodule vcswitch(p, n, ctrl);\n    inout p, n;\n    input ctrl;\n    electrical p, n, ctrl;\n    \n    parameter real ron = 1;      // On resistance\n    parameter real roff = 1e9;   // Off resistance\n    parameter real vth = 0.5;    // Threshold\n    \n    analog begin\n        if (V(ctrl) &gt; vth)\n            I(p, n) &lt;+ V(p, n) / ron;\n        else\n            I(p, n) &lt;+ V(p, n) / roff;\n    end\nendmodule\n</pre>"},{"location":"notebooks/03_schematic_simulation/#6-simulation-tips","title":"6. Simulation Tips\u00b6","text":""},{"location":"notebooks/03_schematic_simulation/#common-issues-and-solutions","title":"Common Issues and Solutions\u00b6","text":"Problem Cause Solution Convergence failure Bad initial conditions Add <code>.nodeset</code> or <code>.ic</code> Slow simulation Too many points Increase step size Oscillation Positive feedback Check connections Wrong DC point Floating nodes Add weak pullup/pulldown"},{"location":"notebooks/03_schematic_simulation/#simulation-checklist","title":"Simulation Checklist\u00b6","text":"<ul> <li>Include correct PDK library</li> <li>Set appropriate simulation time/frequency range</li> <li>Use realistic input waveforms</li> <li>Add load capacitance on outputs</li> <li>Check multiple process corners</li> <li>Verify power consumption</li> </ul>"},{"location":"notebooks/03_schematic_simulation/#summary","title":"Summary\u00b6","text":"<ul> <li>Schematic capture creates a visual circuit representation</li> <li>SPICE simulates circuit behavior with detailed models</li> <li>Analysis types: DC, AC, Transient, Operating Point</li> <li>PDK libraries provide calibrated device models</li> <li>Corner simulation ensures robustness across process variation</li> </ul>"},{"location":"notebooks/03_schematic_simulation/#homework","title":"Homework\u00b6","text":"<ol> <li>Draw a 2-input NAND schematic using PDK cells</li> <li>Simulate in SPICE: verify truth table</li> <li>Measure propagation delay (tpd)</li> <li>Pick your project!</li> </ol>"},{"location":"notebooks/04_layout_fabrication/","title":"Layout & Fabrication","text":"Layout &amp; Fabrication <p>Week 2, Session 2 \u2014 Fab Futures</p> In\u00a0[1]: Copied! <pre># Setup\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import FancyBboxPatch, Rectangle, Circle, FancyArrowPatch\nfrom matplotlib.collections import PatchCollection\nimport numpy as np\n\n# Layer colors for visualizations\nM1_COLOR = '#2196F3'   # Metal 1 - blue\nM2_COLOR = '#FF9800'   # Metal 2 - orange\nVIA_COLOR = '#9C27B0'  # Via - purple\n\nprint(\"Setup complete.\")\n</pre> # Setup import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.patches import FancyBboxPatch, Rectangle, Circle, FancyArrowPatch from matplotlib.collections import PatchCollection import numpy as np  # Layer colors for visualizations M1_COLOR = '#2196F3'   # Metal 1 - blue M2_COLOR = '#FF9800'   # Metal 2 - orange VIA_COLOR = '#9C27B0'  # Via - purple  print(\"Setup complete.\") <pre>Setup complete.\n</pre> <p></p> <p>There are several different layout flows depending on your design type:</p> In\u00a0[2]: Copied! <pre># Visualizing cell hierarchy\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n\n# Left: Flat view (all polygons)\nax1.set_title(\"Flat View (All Polygons)\", fontsize=12)\n# Draw a 3x2 array of identical \"cells\"\nfor i in range(3):\n    for j in range(2):\n        x_off, y_off = i * 12, j * 10\n        # Each \"cell\" has same geometry\n        ax1.add_patch(patches.Rectangle((x_off + 1, y_off + 1), 8, 6, \n                      facecolor=M1_COLOR, alpha=0.6, edgecolor='black'))\n        ax1.add_patch(patches.Rectangle((x_off + 3, y_off + 3), 2, 2, \n                      facecolor=VIA_COLOR, alpha=0.8, edgecolor='black'))\nax1.set_xlim(-1, 37)\nax1.set_ylim(-1, 21)\nax1.set_aspect('equal')\nax1.grid(True, alpha=0.3)\nax1.set_xlabel('x (\u00b5m)')\nax1.set_ylabel('y (\u00b5m)')\n\n# Right: Hierarchical view\nax2.set_title(\"Hierarchical View (Cell References)\", fontsize=12)\n# Draw the base cell once\nax2.add_patch(patches.Rectangle((1, 12), 8, 6, \n              facecolor=M1_COLOR, alpha=0.6, edgecolor='black', linewidth=2))\nax2.add_patch(patches.Rectangle((3, 14), 2, 2, \n              facecolor=VIA_COLOR, alpha=0.8, edgecolor='black'))\nax2.text(5, 15, 'unit_cell', ha='center', va='center', fontsize=10, fontweight='bold')\n\n# Show it's referenced multiple times\nfor i in range(3):\n    for j in range(2):\n        x_off, y_off = i * 12 + 1, j * 5\n        ax2.add_patch(patches.Rectangle((x_off, y_off), 8, 3, \n                      facecolor='none', edgecolor='gray', linestyle='--', linewidth=1))\n        ax2.text(x_off + 4, y_off + 1.5, f'ref', ha='center', va='center', \n                fontsize=8, color='gray')\n\n# Arrow showing relationship\nax2.annotate('', xy=(5, 11), xytext=(5, 9),\n            arrowprops=dict(arrowstyle='-&gt;', color='red', lw=2))\nax2.text(7, 10, 'instantiated\\n6 times', fontsize=9, color='red')\n\nax2.set_xlim(-1, 37)\nax2.set_ylim(-1, 21)\nax2.set_aspect('equal')\nax2.grid(True, alpha=0.3)\nax2.set_xlabel('x (\u00b5m)')\nax2.set_ylabel('y (\u00b5m)')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"Hierarchy reduces file size: instead of storing 6 copies of geometry,\")\nprint(\"we store 1 cell definition + 6 references (position, rotation, scale).\")\n</pre> # Visualizing cell hierarchy fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))  # Left: Flat view (all polygons) ax1.set_title(\"Flat View (All Polygons)\", fontsize=12) # Draw a 3x2 array of identical \"cells\" for i in range(3):     for j in range(2):         x_off, y_off = i * 12, j * 10         # Each \"cell\" has same geometry         ax1.add_patch(patches.Rectangle((x_off + 1, y_off + 1), 8, 6,                        facecolor=M1_COLOR, alpha=0.6, edgecolor='black'))         ax1.add_patch(patches.Rectangle((x_off + 3, y_off + 3), 2, 2,                        facecolor=VIA_COLOR, alpha=0.8, edgecolor='black')) ax1.set_xlim(-1, 37) ax1.set_ylim(-1, 21) ax1.set_aspect('equal') ax1.grid(True, alpha=0.3) ax1.set_xlabel('x (\u00b5m)') ax1.set_ylabel('y (\u00b5m)')  # Right: Hierarchical view ax2.set_title(\"Hierarchical View (Cell References)\", fontsize=12) # Draw the base cell once ax2.add_patch(patches.Rectangle((1, 12), 8, 6,                facecolor=M1_COLOR, alpha=0.6, edgecolor='black', linewidth=2)) ax2.add_patch(patches.Rectangle((3, 14), 2, 2,                facecolor=VIA_COLOR, alpha=0.8, edgecolor='black')) ax2.text(5, 15, 'unit_cell', ha='center', va='center', fontsize=10, fontweight='bold')  # Show it's referenced multiple times for i in range(3):     for j in range(2):         x_off, y_off = i * 12 + 1, j * 5         ax2.add_patch(patches.Rectangle((x_off, y_off), 8, 3,                        facecolor='none', edgecolor='gray', linestyle='--', linewidth=1))         ax2.text(x_off + 4, y_off + 1.5, f'ref', ha='center', va='center',                  fontsize=8, color='gray')  # Arrow showing relationship ax2.annotate('', xy=(5, 11), xytext=(5, 9),             arrowprops=dict(arrowstyle='-&gt;', color='red', lw=2)) ax2.text(7, 10, 'instantiated\\n6 times', fontsize=9, color='red')  ax2.set_xlim(-1, 37) ax2.set_ylim(-1, 21) ax2.set_aspect('equal') ax2.grid(True, alpha=0.3) ax2.set_xlabel('x (\u00b5m)') ax2.set_ylabel('y (\u00b5m)')  plt.tight_layout() plt.show()  print(\"Hierarchy reduces file size: instead of storing 6 copies of geometry,\") print(\"we store 1 cell definition + 6 references (position, rotation, scale).\") <pre>Hierarchy reduces file size: instead of storing 6 copies of geometry,\nwe store 1 cell definition + 6 references (position, rotation, scale).\n</pre> <p></p> In\u00a0[3]: Copied! <pre># DRC: Minimum Width\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\nmin_width = 1.0  # Minimum width rule: 1\u00b5m\n\n# Good: meets minimum width\nax1.add_patch(patches.Rectangle((1, 1), 1.2, 6, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax1.annotate('', xy=(1, 4), xytext=(2.2, 4), arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=2))\nax1.text(1.6, 4.5, '1.2 um', ha='center', fontsize=10, color='green', fontweight='bold')\nax1.text(1.6, 0.3, f'Min width = {min_width} um', ha='center', fontsize=9)\nax1.set_title('PASS: Meets Min Width', fontsize=12, color='green')\nax1.set_xlim(0, 4)\nax1.set_ylim(0, 8)\nax1.set_aspect('equal')\nax1.grid(True, alpha=0.3)\n\n# Bad: violates minimum width  \nax2.add_patch(patches.Rectangle((1, 1), 0.6, 6, facecolor=M1_COLOR, alpha=0.7, edgecolor='red', linewidth=3))\nax2.annotate('', xy=(1, 4), xytext=(1.6, 4), arrowprops=dict(arrowstyle='&lt;-&gt;', color='red', lw=2))\nax2.text(1.3, 4.5, '0.6 um', ha='center', fontsize=10, color='red', fontweight='bold')\nax2.text(1.3, 0.3, f'Min width = {min_width} um', ha='center', fontsize=9)\nax2.set_title('FAIL: Min Width Violation', fontsize=12, color='red')\nax2.set_xlim(0, 4)\nax2.set_ylim(0, 8)\nax2.set_aspect('equal')\nax2.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</pre> # DRC: Minimum Width fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))  min_width = 1.0  # Minimum width rule: 1\u00b5m  # Good: meets minimum width ax1.add_patch(patches.Rectangle((1, 1), 1.2, 6, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax1.annotate('', xy=(1, 4), xytext=(2.2, 4), arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=2)) ax1.text(1.6, 4.5, '1.2 um', ha='center', fontsize=10, color='green', fontweight='bold') ax1.text(1.6, 0.3, f'Min width = {min_width} um', ha='center', fontsize=9) ax1.set_title('PASS: Meets Min Width', fontsize=12, color='green') ax1.set_xlim(0, 4) ax1.set_ylim(0, 8) ax1.set_aspect('equal') ax1.grid(True, alpha=0.3)  # Bad: violates minimum width   ax2.add_patch(patches.Rectangle((1, 1), 0.6, 6, facecolor=M1_COLOR, alpha=0.7, edgecolor='red', linewidth=3)) ax2.annotate('', xy=(1, 4), xytext=(1.6, 4), arrowprops=dict(arrowstyle='&lt;-&gt;', color='red', lw=2)) ax2.text(1.3, 4.5, '0.6 um', ha='center', fontsize=10, color='red', fontweight='bold') ax2.text(1.3, 0.3, f'Min width = {min_width} um', ha='center', fontsize=9) ax2.set_title('FAIL: Min Width Violation', fontsize=12, color='red') ax2.set_xlim(0, 4) ax2.set_ylim(0, 8) ax2.set_aspect('equal') ax2.grid(True, alpha=0.3)  plt.tight_layout() plt.show() In\u00a0[4]: Copied! <pre># DRC: Minimum Spacing\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\nmin_space = 1.5  # Minimum spacing rule: 1.5\u00b5m\n\n# Good: adequate spacing\nax1.add_patch(patches.Rectangle((0, 1), 3, 5, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax1.add_patch(patches.Rectangle((5, 1), 3, 5, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax1.annotate('', xy=(3, 3.5), xytext=(5, 3.5), arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=2))\nax1.text(4, 4.2, '2.0 um', ha='center', fontsize=10, color='green', fontweight='bold')\nax1.text(4, 0.3, f'Min spacing = {min_space} um', ha='center', fontsize=9)\nax1.set_title('PASS: Meets Min Spacing', fontsize=12, color='green')\nax1.set_xlim(-1, 9)\nax1.set_ylim(0, 7)\nax1.set_aspect('equal')\nax1.grid(True, alpha=0.3)\n\n# Bad: spacing violation\nax2.add_patch(patches.Rectangle((0, 1), 3, 5, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax2.add_patch(patches.Rectangle((3.8, 1), 3, 5, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\n# Highlight the violation area\nax2.add_patch(patches.Rectangle((3, 1), 0.8, 5, facecolor='red', alpha=0.3, edgecolor='red', linewidth=2))\nax2.annotate('', xy=(3, 3.5), xytext=(3.8, 3.5), arrowprops=dict(arrowstyle='&lt;-&gt;', color='red', lw=2))\nax2.text(3.4, 4.2, '0.8 um', ha='center', fontsize=10, color='red', fontweight='bold')\nax2.text(3.4, 0.3, f'Min spacing = {min_space} um', ha='center', fontsize=9)\nax2.set_title('FAIL: Min Spacing Violation', fontsize=12, color='red')\nax2.set_xlim(-1, 9)\nax2.set_ylim(0, 7)\nax2.set_aspect('equal')\nax2.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</pre> # DRC: Minimum Spacing fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))  min_space = 1.5  # Minimum spacing rule: 1.5\u00b5m  # Good: adequate spacing ax1.add_patch(patches.Rectangle((0, 1), 3, 5, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax1.add_patch(patches.Rectangle((5, 1), 3, 5, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax1.annotate('', xy=(3, 3.5), xytext=(5, 3.5), arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=2)) ax1.text(4, 4.2, '2.0 um', ha='center', fontsize=10, color='green', fontweight='bold') ax1.text(4, 0.3, f'Min spacing = {min_space} um', ha='center', fontsize=9) ax1.set_title('PASS: Meets Min Spacing', fontsize=12, color='green') ax1.set_xlim(-1, 9) ax1.set_ylim(0, 7) ax1.set_aspect('equal') ax1.grid(True, alpha=0.3)  # Bad: spacing violation ax2.add_patch(patches.Rectangle((0, 1), 3, 5, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax2.add_patch(patches.Rectangle((3.8, 1), 3, 5, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) # Highlight the violation area ax2.add_patch(patches.Rectangle((3, 1), 0.8, 5, facecolor='red', alpha=0.3, edgecolor='red', linewidth=2)) ax2.annotate('', xy=(3, 3.5), xytext=(3.8, 3.5), arrowprops=dict(arrowstyle='&lt;-&gt;', color='red', lw=2)) ax2.text(3.4, 4.2, '0.8 um', ha='center', fontsize=10, color='red', fontweight='bold') ax2.text(3.4, 0.3, f'Min spacing = {min_space} um', ha='center', fontsize=9) ax2.set_title('FAIL: Min Spacing Violation', fontsize=12, color='red') ax2.set_xlim(-1, 9) ax2.set_ylim(0, 7) ax2.set_aspect('equal') ax2.grid(True, alpha=0.3)  plt.tight_layout() plt.show() In\u00a0[5]: Copied! <pre># DRC: Enclosure Rules\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\nmin_enclosure = 0.5  # Via must be enclosed by 0.5\u00b5m of metal on all sides\n\n# Good: proper enclosure\nax1.add_patch(patches.Rectangle((1, 1), 4, 4, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax1.add_patch(patches.Rectangle((2, 2), 2, 2, facecolor=VIA_COLOR, alpha=0.9, edgecolor='black'))\n# Show enclosure dimension\nax1.annotate('', xy=(1, 2.5), xytext=(2, 2.5), arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=1.5))\nax1.text(1.5, 2.8, '1.0', ha='center', fontsize=9, color='green')\nax1.text(3, 0.3, f'Min enclosure = {min_enclosure} um', ha='center', fontsize=9)\nax1.set_title('PASS: Proper Via Enclosure', fontsize=12, color='green')\nax1.set_xlim(0, 6)\nax1.set_ylim(0, 6)\nax1.set_aspect('equal')\nax1.grid(True, alpha=0.3)\n# Legend\nax1.add_patch(patches.Rectangle((4.5, 5), 0.4, 0.4, facecolor=M1_COLOR, alpha=0.7))\nax1.text(5, 5.2, 'Metal', fontsize=8)\nax1.add_patch(patches.Rectangle((4.5, 4.3), 0.4, 0.4, facecolor=VIA_COLOR, alpha=0.9))\nax1.text(5, 4.5, 'Via', fontsize=8)\n\n# Bad: enclosure violation\nax2.add_patch(patches.Rectangle((1, 1), 3, 4, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax2.add_patch(patches.Rectangle((1.8, 2), 2, 2, facecolor=VIA_COLOR, alpha=0.9, edgecolor='red', linewidth=3))\n# Highlight the problem area\nax2.add_patch(patches.FancyBboxPatch((3.5, 2), 0.5, 2, facecolor='red', alpha=0.3,\n              boxstyle='round,pad=0.05'))\nax2.annotate('', xy=(3.8, 3), xytext=(4, 3), arrowprops=dict(arrowstyle='&lt;-&gt;', color='red', lw=1.5))\nax2.text(4.3, 3, '0.2', ha='left', fontsize=9, color='red')\nax2.text(2.5, 0.3, f'Min enclosure = {min_enclosure} um', ha='center', fontsize=9)\nax2.text(4.5, 2.5, 'Via extends\\nbeyond metal!', fontsize=9, color='red', ha='center')\nax2.set_title('FAIL: Enclosure Violation', fontsize=12, color='red')\nax2.set_xlim(0, 6)\nax2.set_ylim(0, 6)\nax2.set_aspect('equal')\nax2.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</pre> # DRC: Enclosure Rules fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))  min_enclosure = 0.5  # Via must be enclosed by 0.5\u00b5m of metal on all sides  # Good: proper enclosure ax1.add_patch(patches.Rectangle((1, 1), 4, 4, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax1.add_patch(patches.Rectangle((2, 2), 2, 2, facecolor=VIA_COLOR, alpha=0.9, edgecolor='black')) # Show enclosure dimension ax1.annotate('', xy=(1, 2.5), xytext=(2, 2.5), arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=1.5)) ax1.text(1.5, 2.8, '1.0', ha='center', fontsize=9, color='green') ax1.text(3, 0.3, f'Min enclosure = {min_enclosure} um', ha='center', fontsize=9) ax1.set_title('PASS: Proper Via Enclosure', fontsize=12, color='green') ax1.set_xlim(0, 6) ax1.set_ylim(0, 6) ax1.set_aspect('equal') ax1.grid(True, alpha=0.3) # Legend ax1.add_patch(patches.Rectangle((4.5, 5), 0.4, 0.4, facecolor=M1_COLOR, alpha=0.7)) ax1.text(5, 5.2, 'Metal', fontsize=8) ax1.add_patch(patches.Rectangle((4.5, 4.3), 0.4, 0.4, facecolor=VIA_COLOR, alpha=0.9)) ax1.text(5, 4.5, 'Via', fontsize=8)  # Bad: enclosure violation ax2.add_patch(patches.Rectangle((1, 1), 3, 4, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax2.add_patch(patches.Rectangle((1.8, 2), 2, 2, facecolor=VIA_COLOR, alpha=0.9, edgecolor='red', linewidth=3)) # Highlight the problem area ax2.add_patch(patches.FancyBboxPatch((3.5, 2), 0.5, 2, facecolor='red', alpha=0.3,               boxstyle='round,pad=0.05')) ax2.annotate('', xy=(3.8, 3), xytext=(4, 3), arrowprops=dict(arrowstyle='&lt;-&gt;', color='red', lw=1.5)) ax2.text(4.3, 3, '0.2', ha='left', fontsize=9, color='red') ax2.text(2.5, 0.3, f'Min enclosure = {min_enclosure} um', ha='center', fontsize=9) ax2.text(4.5, 2.5, 'Via extends\\nbeyond metal!', fontsize=9, color='red', ha='center') ax2.set_title('FAIL: Enclosure Violation', fontsize=12, color='red') ax2.set_xlim(0, 6) ax2.set_ylim(0, 6) ax2.set_aspect('equal') ax2.grid(True, alpha=0.3)  plt.tight_layout() plt.show() In\u00a0[6]: Copied! <pre># DRC: Metal Density\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 4))\n\n# Window for density check\nwindow_size = 10\n\ndef add_density_window(ax):\n    ax.add_patch(patches.Rectangle((0, 0), window_size, window_size, \n                 facecolor='none', edgecolor='gray', linestyle='--', linewidth=2))\n    ax.set_xlim(-1, 11)\n    ax.set_ylim(-1, 11)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n\n# Too sparse (&lt; 20%)\nax1.add_patch(patches.Rectangle((4, 4), 2, 2, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nadd_density_window(ax1)\nax1.set_title('FAIL: Too Sparse (4%)\\nMin density: 20%', fontsize=11, color='red')\nax1.text(5, -0.5, 'CMP issues: dishing', ha='center', fontsize=9, style='italic')\n\n# Good density (40-60%)\nfor i in range(5):\n    for j in range(5):\n        if (i + j) % 2 == 0:\n            ax2.add_patch(patches.Rectangle((i*2, j*2), 1.5, 1.5, \n                          facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nadd_density_window(ax2)\nax2.set_title('PASS: Good Density (~50%)\\nTarget: 30-70%', fontsize=11, color='green')\n\n# Too dense (&gt; 80%)\nax3.add_patch(patches.Rectangle((0.5, 0.5), 9, 9, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\n# Small gaps\nax3.add_patch(patches.Rectangle((3, 3), 0.5, 4, facecolor='white', edgecolor='black'))\nax3.add_patch(patches.Rectangle((6, 3), 0.5, 4, facecolor='white', edgecolor='black'))\nadd_density_window(ax3)\nax3.set_title('FAIL: Too Dense (&gt;85%)\\nMax density: 80%', fontsize=11, color='red')\nax3.text(5, -0.5, 'CMP issues: erosion', ha='center', fontsize=9, style='italic')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"Density rules ensure uniform polishing during CMP (Chemical Mechanical Planarization).\")\nprint(\"Fill patterns are often auto-generated to meet density requirements.\")\n</pre> # DRC: Metal Density fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 4))  # Window for density check window_size = 10  def add_density_window(ax):     ax.add_patch(patches.Rectangle((0, 0), window_size, window_size,                   facecolor='none', edgecolor='gray', linestyle='--', linewidth=2))     ax.set_xlim(-1, 11)     ax.set_ylim(-1, 11)     ax.set_aspect('equal')     ax.grid(True, alpha=0.3)  # Too sparse (&lt; 20%) ax1.add_patch(patches.Rectangle((4, 4), 2, 2, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) add_density_window(ax1) ax1.set_title('FAIL: Too Sparse (4%)\\nMin density: 20%', fontsize=11, color='red') ax1.text(5, -0.5, 'CMP issues: dishing', ha='center', fontsize=9, style='italic')  # Good density (40-60%) for i in range(5):     for j in range(5):         if (i + j) % 2 == 0:             ax2.add_patch(patches.Rectangle((i*2, j*2), 1.5, 1.5,                            facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) add_density_window(ax2) ax2.set_title('PASS: Good Density (~50%)\\nTarget: 30-70%', fontsize=11, color='green')  # Too dense (&gt; 80%) ax3.add_patch(patches.Rectangle((0.5, 0.5), 9, 9, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) # Small gaps ax3.add_patch(patches.Rectangle((3, 3), 0.5, 4, facecolor='white', edgecolor='black')) ax3.add_patch(patches.Rectangle((6, 3), 0.5, 4, facecolor='white', edgecolor='black')) add_density_window(ax3) ax3.set_title('FAIL: Too Dense (&gt;85%)\\nMax density: 80%', fontsize=11, color='red') ax3.text(5, -0.5, 'CMP issues: erosion', ha='center', fontsize=9, style='italic')  plt.tight_layout() plt.show()  print(\"Density rules ensure uniform polishing during CMP (Chemical Mechanical Planarization).\") print(\"Fill patterns are often auto-generated to meet density requirements.\") <pre>Density rules ensure uniform polishing during CMP (Chemical Mechanical Planarization).\nFill patterns are often auto-generated to meet density requirements.\n</pre> In\u00a0[7]: Copied! <pre># LVS: Common errors\nfig, axes = plt.subplots(1, 3, figsize=(15, 4))\n\n# Correct connectivity\nax = axes[0]\nax.add_patch(patches.Rectangle((0, 2), 4, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax.add_patch(patches.Rectangle((6, 2), 4, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax.add_patch(patches.Rectangle((4, 0), 2, 5, facecolor=M2_COLOR, alpha=0.7, edgecolor='black'))\nax.add_patch(patches.Rectangle((4.5, 2.25), 1, 0.5, facecolor=VIA_COLOR, alpha=0.9, edgecolor='black'))\nax.text(2, 3.5, 'Net A', ha='center', fontsize=10)\nax.text(8, 3.5, 'Net A', ha='center', fontsize=10)\nax.set_title('PASS: Connected via M2', fontsize=11, color='green')\nax.set_xlim(-1, 11)\nax.set_ylim(-1, 6)\nax.set_aspect('equal')\nax.grid(True, alpha=0.3)\n\n# Open circuit (missing via)\nax = axes[1]\nax.add_patch(patches.Rectangle((0, 2), 4, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax.add_patch(patches.Rectangle((6, 2), 4, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax.add_patch(patches.Rectangle((4, 0), 2, 5, facecolor=M2_COLOR, alpha=0.7, edgecolor='black'))\n# Missing via!\nax.add_patch(patches.Circle((5, 2.5), 0.8, facecolor='none', edgecolor='red', linewidth=3, linestyle='--'))\nax.text(5, 2.5, '?', ha='center', va='center', fontsize=14, color='red', fontweight='bold')\nax.text(2, 3.5, 'Net A', ha='center', fontsize=10)\nax.text(8, 3.5, 'Net B', ha='center', fontsize=10, color='red')\nax.set_title('FAIL: Open - Missing Via', fontsize=11, color='red')\nax.set_xlim(-1, 11)\nax.set_ylim(-1, 6)\nax.set_aspect('equal')\nax.grid(True, alpha=0.3)\n\n# Short circuit (unintended connection)\nax = axes[2]\nax.add_patch(patches.Rectangle((0, 3), 10, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\nax.add_patch(patches.Rectangle((0, 0), 10, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black'))\n# Unintended bridge\nax.add_patch(patches.Rectangle((4.5, 1), 1, 2, facecolor=M1_COLOR, alpha=0.7, edgecolor='red', linewidth=3))\nax.text(5, 4.5, 'Net A', ha='center', fontsize=10)\nax.text(5, -0.5, 'Net B (should be separate)', ha='center', fontsize=10)\nax.annotate('SHORT!', xy=(5, 2), fontsize=12, color='red', fontweight='bold',\n           ha='center', bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.8))\nax.set_title('FAIL: Short - Unintended Bridge', fontsize=11, color='red')\nax.set_xlim(-1, 11)\nax.set_ylim(-1, 6)\nax.set_aspect('equal')\nax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</pre> # LVS: Common errors fig, axes = plt.subplots(1, 3, figsize=(15, 4))  # Correct connectivity ax = axes[0] ax.add_patch(patches.Rectangle((0, 2), 4, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax.add_patch(patches.Rectangle((6, 2), 4, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax.add_patch(patches.Rectangle((4, 0), 2, 5, facecolor=M2_COLOR, alpha=0.7, edgecolor='black')) ax.add_patch(patches.Rectangle((4.5, 2.25), 1, 0.5, facecolor=VIA_COLOR, alpha=0.9, edgecolor='black')) ax.text(2, 3.5, 'Net A', ha='center', fontsize=10) ax.text(8, 3.5, 'Net A', ha='center', fontsize=10) ax.set_title('PASS: Connected via M2', fontsize=11, color='green') ax.set_xlim(-1, 11) ax.set_ylim(-1, 6) ax.set_aspect('equal') ax.grid(True, alpha=0.3)  # Open circuit (missing via) ax = axes[1] ax.add_patch(patches.Rectangle((0, 2), 4, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax.add_patch(patches.Rectangle((6, 2), 4, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax.add_patch(patches.Rectangle((4, 0), 2, 5, facecolor=M2_COLOR, alpha=0.7, edgecolor='black')) # Missing via! ax.add_patch(patches.Circle((5, 2.5), 0.8, facecolor='none', edgecolor='red', linewidth=3, linestyle='--')) ax.text(5, 2.5, '?', ha='center', va='center', fontsize=14, color='red', fontweight='bold') ax.text(2, 3.5, 'Net A', ha='center', fontsize=10) ax.text(8, 3.5, 'Net B', ha='center', fontsize=10, color='red') ax.set_title('FAIL: Open - Missing Via', fontsize=11, color='red') ax.set_xlim(-1, 11) ax.set_ylim(-1, 6) ax.set_aspect('equal') ax.grid(True, alpha=0.3)  # Short circuit (unintended connection) ax = axes[2] ax.add_patch(patches.Rectangle((0, 3), 10, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) ax.add_patch(patches.Rectangle((0, 0), 10, 1, facecolor=M1_COLOR, alpha=0.7, edgecolor='black')) # Unintended bridge ax.add_patch(patches.Rectangle((4.5, 1), 1, 2, facecolor=M1_COLOR, alpha=0.7, edgecolor='red', linewidth=3)) ax.text(5, 4.5, 'Net A', ha='center', fontsize=10) ax.text(5, -0.5, 'Net B (should be separate)', ha='center', fontsize=10) ax.annotate('SHORT!', xy=(5, 2), fontsize=12, color='red', fontweight='bold',            ha='center', bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.8)) ax.set_title('FAIL: Short - Unintended Bridge', fontsize=11, color='red') ax.set_xlim(-1, 11) ax.set_ylim(-1, 6) ax.set_aspect('equal') ax.grid(True, alpha=0.3)  plt.tight_layout() plt.show() <p></p> <p>A PDK (Process Development Kit) provides everything you need to design for a specific fab process:</p> Component Purpose Layer Maps Defines which GDS layers correspond to which physical layers Feature Sizes Minimum/maximum dimensions for each layer Design Rules DRC rule deck for the process Device Models SPICE models for transistors, resistors, capacitors Standard Cells Pre-designed logic gates (for digital flows) In\u00a0[8]: Copied! <pre># Example: Layer stackup visualization\nfig, ax = plt.subplots(figsize=(10, 6))\n\nlayers = [\n    ('Substrate', '#8B4513', 0, 2),\n    ('Field Oxide', '#D3D3D3', 2, 0.5),\n    ('Poly / Active', '#4CAF50', 2.5, 0.3),\n    ('ILD 1', '#ADD8E6', 2.8, 0.8),\n    ('Metal 1', '#2196F3', 3.6, 0.4),\n    ('ILD 2', '#ADD8E6', 4.0, 0.8),\n    ('Metal 2', '#FF9800', 4.8, 0.5),\n    ('Passivation', '#90EE90', 5.3, 0.4),\n]\n\nfor name, color, y, height in layers:\n    ax.add_patch(patches.Rectangle((0, y), 10, height, \n                 facecolor=color, edgecolor='black', linewidth=0.5))\n    ax.text(10.5, y + height/2, name, va='center', fontsize=10)\n\n# Add via between M1 and M2\nax.add_patch(patches.Rectangle((4.5, 4.0), 1, 0.8, facecolor='#9C27B0', edgecolor='black'))\nax.text(5, 4.4, 'Via', ha='center', va='center', fontsize=8, color='white')\n\n# Add contact to poly\nax.add_patch(patches.Rectangle((2.5, 2.8), 0.5, 0.8, facecolor='#9C27B0', edgecolor='black'))\n\nax.set_xlim(-0.5, 14)\nax.set_ylim(-0.5, 6.5)\nax.set_aspect('equal')\nax.set_title('Simplified Layer Stackup Cross-Section', fontsize=12)\nax.set_ylabel('Height')\nax.set_xticks([])\n\nplt.tight_layout()\nplt.show()\n</pre> # Example: Layer stackup visualization fig, ax = plt.subplots(figsize=(10, 6))  layers = [     ('Substrate', '#8B4513', 0, 2),     ('Field Oxide', '#D3D3D3', 2, 0.5),     ('Poly / Active', '#4CAF50', 2.5, 0.3),     ('ILD 1', '#ADD8E6', 2.8, 0.8),     ('Metal 1', '#2196F3', 3.6, 0.4),     ('ILD 2', '#ADD8E6', 4.0, 0.8),     ('Metal 2', '#FF9800', 4.8, 0.5),     ('Passivation', '#90EE90', 5.3, 0.4), ]  for name, color, y, height in layers:     ax.add_patch(patches.Rectangle((0, y), 10, height,                   facecolor=color, edgecolor='black', linewidth=0.5))     ax.text(10.5, y + height/2, name, va='center', fontsize=10)  # Add via between M1 and M2 ax.add_patch(patches.Rectangle((4.5, 4.0), 1, 0.8, facecolor='#9C27B0', edgecolor='black')) ax.text(5, 4.4, 'Via', ha='center', va='center', fontsize=8, color='white')  # Add contact to poly ax.add_patch(patches.Rectangle((2.5, 2.8), 0.5, 0.8, facecolor='#9C27B0', edgecolor='black'))  ax.set_xlim(-0.5, 14) ax.set_ylim(-0.5, 6.5) ax.set_aspect('equal') ax.set_title('Simplified Layer Stackup Cross-Section', fontsize=12) ax.set_ylabel('Height') ax.set_xticks([])  plt.tight_layout() plt.show() <p></p> <p></p> <p></p> <p></p> In\u00a0[9]: Copied! <pre># Visualizing the basic fabrication cycle\nfig, axes = plt.subplots(2, 3, figsize=(14, 8))\naxes = axes.flatten()\n\ndef draw_cross_section(ax, title, substrate=True, metal=None, oxide=None, resist=None, annotation=None):\n    \"\"\"Draw a simplified cross-section.\"\"\"\n    if substrate:\n        ax.add_patch(patches.Rectangle((0, 0), 10, 1.5, facecolor='#8B4513'))\n        ax.text(5, 0.75, 'Substrate', ha='center', va='center', color='white', fontsize=9)\n    if oxide:\n        ax.add_patch(patches.Rectangle((0, 1.5), 10, oxide, facecolor='#ADD8E6'))\n    if metal == 'full':\n        ax.add_patch(patches.Rectangle((0, 1.5), 10, 0.5, facecolor='#C0C0C0', edgecolor='black'))\n    elif metal == 'patterned':\n        ax.add_patch(patches.Rectangle((0, 1.5), 3, 0.5, facecolor='#C0C0C0', edgecolor='black'))\n        ax.add_patch(patches.Rectangle((7, 1.5), 3, 0.5, facecolor='#C0C0C0', edgecolor='black'))\n    if resist == 'full':\n        ax.add_patch(patches.Rectangle((0, 2.0), 10, 0.4, facecolor='#FFB6C1', edgecolor='black'))\n    elif resist == 'patterned':\n        ax.add_patch(patches.Rectangle((0, 2.0), 3, 0.4, facecolor='#FFB6C1', edgecolor='black'))\n        ax.add_patch(patches.Rectangle((7, 2.0), 3, 0.4, facecolor='#FFB6C1', edgecolor='black'))\n    if annotation:\n        ax.annotate(annotation[0], xy=annotation[1], fontsize=10, ha='center',\n                   bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.8))\n    ax.set_xlim(-0.5, 10.5)\n    ax.set_ylim(-0.2, 3.5)\n    ax.set_aspect('equal')\n    ax.set_title(title, fontsize=11)\n    ax.axis('off')\n\ndraw_cross_section(axes[0], \"1. Start: Clean Substrate\")\ndraw_cross_section(axes[1], \"2. Deposit Metal\", metal='full')\ndraw_cross_section(axes[2], \"3. Coat with Photoresist\", metal='full', resist='full')\ndraw_cross_section(axes[3], \"4. Expose &amp; Develop Resist\", metal='full', resist='patterned',\n                  annotation=('UV Light\\nexposed here', (5, 2.8)))\ndraw_cross_section(axes[4], \"5. Etch Metal\", metal='patterned', resist='patterned')\ndraw_cross_section(axes[5], \"6. Strip Resist \u2192 Done!\", metal='patterned')\n\nplt.tight_layout()\nplt.show()\n</pre> # Visualizing the basic fabrication cycle fig, axes = plt.subplots(2, 3, figsize=(14, 8)) axes = axes.flatten()  def draw_cross_section(ax, title, substrate=True, metal=None, oxide=None, resist=None, annotation=None):     \"\"\"Draw a simplified cross-section.\"\"\"     if substrate:         ax.add_patch(patches.Rectangle((0, 0), 10, 1.5, facecolor='#8B4513'))         ax.text(5, 0.75, 'Substrate', ha='center', va='center', color='white', fontsize=9)     if oxide:         ax.add_patch(patches.Rectangle((0, 1.5), 10, oxide, facecolor='#ADD8E6'))     if metal == 'full':         ax.add_patch(patches.Rectangle((0, 1.5), 10, 0.5, facecolor='#C0C0C0', edgecolor='black'))     elif metal == 'patterned':         ax.add_patch(patches.Rectangle((0, 1.5), 3, 0.5, facecolor='#C0C0C0', edgecolor='black'))         ax.add_patch(patches.Rectangle((7, 1.5), 3, 0.5, facecolor='#C0C0C0', edgecolor='black'))     if resist == 'full':         ax.add_patch(patches.Rectangle((0, 2.0), 10, 0.4, facecolor='#FFB6C1', edgecolor='black'))     elif resist == 'patterned':         ax.add_patch(patches.Rectangle((0, 2.0), 3, 0.4, facecolor='#FFB6C1', edgecolor='black'))         ax.add_patch(patches.Rectangle((7, 2.0), 3, 0.4, facecolor='#FFB6C1', edgecolor='black'))     if annotation:         ax.annotate(annotation[0], xy=annotation[1], fontsize=10, ha='center',                    bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.8))     ax.set_xlim(-0.5, 10.5)     ax.set_ylim(-0.2, 3.5)     ax.set_aspect('equal')     ax.set_title(title, fontsize=11)     ax.axis('off')  draw_cross_section(axes[0], \"1. Start: Clean Substrate\") draw_cross_section(axes[1], \"2. Deposit Metal\", metal='full') draw_cross_section(axes[2], \"3. Coat with Photoresist\", metal='full', resist='full') draw_cross_section(axes[3], \"4. Expose &amp; Develop Resist\", metal='full', resist='patterned',                   annotation=('UV Light\\nexposed here', (5, 2.8))) draw_cross_section(axes[4], \"5. Etch Metal\", metal='patterned', resist='patterned') draw_cross_section(axes[5], \"6. Strip Resist \u2192 Done!\", metal='patterned')  plt.tight_layout() plt.show() <p></p> <p>This notebook is designed for use with JupyterLite \u2014 runs entirely in your browser!</p>"},{"location":"notebooks/04_layout_fabrication/#contents","title":"Contents\u00b6","text":"<ol> <li>What is Layout?</li> <li>Design Rules</li> <li>DRC: Design Rule Check</li> <li>LVS: Layout vs Schematic</li> <li>The Fabrication Process</li> <li>From GDS to Silicon</li> </ol>"},{"location":"notebooks/04_layout_fabrication/#1-the-layout-process","title":"1. The Layout Process\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#layout-only-layout-first","title":"Layout Only / Layout First\u00b6","text":"<ul> <li>Typically used by the fab for process characterization features</li> <li>Metal and oxide thickness, mask alignment, critical dimension checks</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#analog-flow","title":"Analog Flow\u00b6","text":"<ul> <li>Schematic first, SPICE simulation driven designs</li> <li>Uses schematic-driven placement to match layout components to schematic components</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#digital-rtl-to-gds-flow","title":"Digital / RTL-to-GDS Flow\u00b6","text":"<ul> <li>May skip a schematic &amp; SPICE representation</li> <li>Goes straight from hardware description language and logic simulation (e.g., multipliers or NAND gates) to GDS</li> <li>Substantially automated layout generation and checking</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#cell-hierarchy","title":"Cell Hierarchy\u00b6","text":"<p>Layouts are organized hierarchically \u2014 smaller cells are instantiated inside larger cells:</p>"},{"location":"notebooks/04_layout_fabrication/#2-design-verification","title":"2. Design Verification\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#design-rule-checking-drc","title":"Design Rule Checking (DRC)\u00b6","text":"<p>DRC ensures your layout meets the physical constraints of the fabrication process. These rules exist because of lithography resolution limits, etching characteristics, and reliability requirements.</p> <p>Note: The examples below use simplified values for illustration. Real PDK rules are much more detailed. For reference, here are some actual SkyWater 130nm rules:</p> Rule Illustrative Actual Sky130 M1 min width 1.0 um 0.14 um M1 min space 1.5 um 0.14 um Via enclosure 0.5 um 0.03-0.06 um Metal density 20-80% varies by layer <p>Density rules note: Sky130 density requirements differ by metal layer and process variant (aluminum vs copper). For example, M1 copper has a maximum density of 77% while other layers differ. Always consult the actual PDK documentation: skywater-pdk.readthedocs.io</p>"},{"location":"notebooks/04_layout_fabrication/#minimum-width","title":"Minimum Width\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#minimum-spacing","title":"Minimum Spacing\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#enclosure-rules-via-must-be-enclosed-by-metal","title":"Enclosure Rules (Via must be enclosed by metal)\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#metal-density-rules","title":"Metal Density Rules\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#other-reliability-rules","title":"Other Reliability Rules\u00b6","text":"<p>Beyond basic geometry checks, DRC includes reliability rules:</p> <p>Antenna Rules</p> <ul> <li>During plasma etching, long metal wires can accumulate charge</li> <li>This charge can damage thin gate oxides connected to the wire</li> <li>Fix: Add protective diodes or break long routes with vias to upper metals</li> <li>Tools often auto-fix these; you'll see \"antenna diodes\" in your layout</li> </ul> <p>Electromigration</p> <ul> <li>High current density causes metal atoms to migrate over time</li> <li>Eventually creates voids (opens) or hillocks (shorts)</li> <li>Rule: Minimum wire width depends on expected current</li> <li>Power/ground routes need to be wider than signal routes</li> </ul> <p>These rules matter more for production chips than educational tapeouts, but the DRC deck will flag them regardless.</p>"},{"location":"notebooks/04_layout_fabrication/#layout-vs-schematic-checking-lvs","title":"Layout vs. Schematic Checking (LVS)\u00b6","text":"<p>LVS verifies that your physical layout matches your logical schematic:</p> <ul> <li>Extracts a netlist from the layout geometry</li> <li>Compares against the original schematic netlist</li> <li>Reports mismatches: shorts, opens, missing components, parameter differences</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#3-process-development-kits","title":"3. Process Development Kits\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#4-layout-tools-file-formats","title":"4. Layout Tools &amp; File Formats\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#open-source-tools","title":"Open Source Tools\u00b6","text":"<ul> <li>KLayout \u2014 GUI-based viewer and editor</li> <li>gdsfactory \u2014 Python-based programmatic layout</li> <li>Magic \u2014 Classic tool for CMOS layout</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#commercial-tools","title":"Commercial Tools\u00b6","text":"<ul> <li>Cadence Virtuoso \u2014 Industry standard for analog/mixed-signal</li> <li>Synopsys Custom Compiler \u2014 Alternative commercial option</li> <li>Mentor Calibre \u2014 Industry standard for DRC/LVS</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#file-formats","title":"File Formats\u00b6","text":"Format Use Case GDS (GDSII) Most common, binary format, ~40 years old OASIS More compact \u2014 a 1 GB GDS becomes ~10 MB OASIS LEF/DEF Library Exchange Format / Design Exchange Format (digital flows)"},{"location":"notebooks/04_layout_fabrication/#5-tape-out-layout-acceptance","title":"5. Tape Out &amp; Layout Acceptance\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#tape-out","title":"Tape Out\u00b6","text":"<p>Historical note: The term \"tape out\" comes from a time when designs were sent to the fab on cassette tapes!</p> <p>Today, we just send a file over:</p> <ul> <li>Email</li> <li>SFTP server</li> <li>Secure file transfer portal</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#layout-acceptance","title":"Layout Acceptance\u00b6","text":"<p>Before the fab begins work, they perform their own verification:</p> <ul> <li>DRC with their internal rule deck</li> <li>Layer mapping verification</li> <li>Density checks</li> <li>Antenna rule checks</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#6-fabrication-overview","title":"6. Fabrication Overview\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#a-designers-perspective","title":"A Designer's Perspective\u00b6","text":"<p>Once you send your design off to fabrication, now it's time to wait.</p> <p>Fabrication typically takes ~1 to 6 months depending on complexity.</p>"},{"location":"notebooks/04_layout_fabrication/#in-the-meantime-you-can","title":"In the meantime, you can:\u00b6","text":"<ol> <li><p>Prepare for chip arrival</p> <ul> <li>Set up test equipment (hardware and software)</li> <li>Develop test patterns</li> <li>Make sure you have packaging and wiring ready</li> </ul> </li> <li><p>Start on a new design (if everything is ready)</p> <ul> <li>A backup design variant</li> <li>Something more aggressive</li> <li>Something completely unrelated</li> </ul> </li> </ol>"},{"location":"notebooks/04_layout_fabrication/#a-broader-perspective-foundry-side","title":"A Broader Perspective (Foundry Side)\u00b6","text":"<p>On the foundry side, this is when the work starts:</p>"},{"location":"notebooks/04_layout_fabrication/#1-wafers-allocated","title":"1. Wafers Allocated\u00b6","text":"<ul> <li>Wafers are grown by specialized providers</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#2-masks-ordered","title":"2. Masks Ordered\u00b6","text":"<ul> <li>Typically done by specialized providers (e.g., Toppan, Photronics)</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#3-processpi-sheet-created","title":"3. Process/PI Sheet Created\u00b6","text":"<ul> <li>Defines the processing and metrology steps</li> <li>Defines any splits in a run (e.g., half of the wafers see intentionally different processing parameters at a critical stage)</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#7-the-fabrication-process","title":"7. The Fabrication Process\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#the-basic-cycle","title":"The Basic Cycle\u00b6","text":"<p>1. Deposit material \u2192 2. Define features (photolithography) \u2192 3. Etch material</p> <p>Repeat for each layer</p>"},{"location":"notebooks/04_layout_fabrication/#front-end-vs-back-end-processing","title":"Front End vs Back End Processing\u00b6","text":"<p>Front End (FEOL)</p> <ul> <li>Transistor/device formation</li> <li>Most complex and critical steps</li> <li>Defines device performance</li> </ul> <p>Back End (BEOL)</p> <ul> <li>Metal interconnect layers</li> <li>Repeated deposit \u2192 pattern \u2192 etch cycle</li> <li><code>metal \u2192 dielectric \u2192 metal \u2192 dielectric \u2192 ...</code></li> </ul>"},{"location":"notebooks/04_layout_fabrication/#whats-taking-so-long","title":"What's Taking So Long?\u00b6","text":"Factor Description Inspection steps Quality checks between process steps Queues Waiting for tool availability Rework Fixing issues discovered during inspection Process monitors Test structures to verify process parameters Tool downtime &amp; repairs Equipment maintenance Holds Waiting for engineering decisions"},{"location":"notebooks/04_layout_fabrication/#8-chip-delivery-packaging","title":"8. Chip Delivery &amp; Packaging\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#packaging-options","title":"Packaging Options\u00b6","text":""},{"location":"notebooks/04_layout_fabrication/#bare-die","title":"Bare Die\u00b6","text":"<ul> <li>Gel packs \u2014 Die shipped in protective gel</li> <li>Waffle packs \u2014 Plastic trays with individual pockets</li> <li>Wirebonding \u2014 You handle the packaging</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#packaged-parts","title":"Packaged Parts\u00b6","text":"<ul> <li>DIP / SIP / through-hole packages \u2014 Easy to prototype with</li> <li>SMT / Surface mount packages \u2014 Production-ready</li> <li>BGA / Flip-chip \u2014 High pin count, high performance</li> </ul>"},{"location":"notebooks/04_layout_fabrication/#fabrication-summary-data","title":"Fabrication Summary Data\u00b6","text":"<p>Specifications you might receive with your chips:</p> Measurement What it tells you Sheet resistance Metal and via quality Capacitance Dielectric thickness and quality Line/space CD Critical dimension measurements Defect density Process cleanliness"},{"location":"notebooks/04_layout_fabrication/#summary","title":"Summary\u00b6","text":"<p>Layout \u2192 Verification (DRC/LVS) \u2192 Tape Out \u2192 Fabrication \u2192 Delivery</p> <p>Questions? Let's discuss!</p>"},{"location":"notebooks/05_rtl_design_verification/","title":"RTL Design & Verification","text":"RTL Design &amp; Verification <p>Week 3, Session 1 \u2014 Fab Futures</p> In\u00a0[1]: Copied! <pre># Setup\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import FancyBboxPatch, Circle, FancyArrowPatch\nimport numpy as np\n\nprint(\"Setup complete.\")\n</pre> # Setup import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.patches import FancyBboxPatch, Circle, FancyArrowPatch import numpy as np  print(\"Setup complete.\") <pre>Setup complete.\n</pre> <p></p> <p>RTL (Register-Transfer Level) describes digital circuits in terms of:</p> <ul> <li>Registers (flip-flops that store data)</li> <li>Combinational logic (transforms data between registers)</li> <li>Transfers (data moving from one register to another)</li> </ul> In\u00a0[2]: Copied! <pre># RTL concept: Registers + Combinational Logic\nfig, ax = plt.subplots(figsize=(14, 5))\n\n# Register 1\nax.add_patch(FancyBboxPatch((1, 2), 2, 2, boxstyle=\"round,pad=0.05\",\n             facecolor='#E3F2FD', edgecolor='#1976D2', linewidth=2))\nax.text(2, 3, 'Register A\\n(flip-flops)', ha='center', va='center', fontsize=10)\n\n# Combinational logic\nax.add_patch(FancyBboxPatch((5, 1.5), 3, 3, boxstyle=\"round,pad=0.05\",\n             facecolor='#FFF3E0', edgecolor='#F57C00', linewidth=2))\nax.text(6.5, 3, 'Combinational\\nLogic\\n(AND, OR, +, \u00d7)', ha='center', va='center', fontsize=10)\n\n# Register 2\nax.add_patch(FancyBboxPatch((10, 2), 2, 2, boxstyle=\"round,pad=0.05\",\n             facecolor='#E3F2FD', edgecolor='#1976D2', linewidth=2))\nax.text(11, 3, 'Register B\\n(flip-flops)', ha='center', va='center', fontsize=10)\n\n# Arrows\nax.annotate('', xy=(5, 3), xytext=(3, 3),\n           arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))\nax.annotate('', xy=(10, 3), xytext=(8, 3),\n           arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))\n\n# Clock\nax.plot([2, 2, 11, 11], [0.5, 1.5, 1.5, 2], 'purple', linewidth=2, linestyle='--')\nax.text(6.5, 0.8, 'Clock (synchronizes transfers)', ha='center', fontsize=10, color='purple')\n\nax.set_xlim(0, 13)\nax.set_ylim(0, 5)\nax.set_title('RTL Model: Registers + Combinational Logic + Clock', fontsize=12, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # RTL concept: Registers + Combinational Logic fig, ax = plt.subplots(figsize=(14, 5))  # Register 1 ax.add_patch(FancyBboxPatch((1, 2), 2, 2, boxstyle=\"round,pad=0.05\",              facecolor='#E3F2FD', edgecolor='#1976D2', linewidth=2)) ax.text(2, 3, 'Register A\\n(flip-flops)', ha='center', va='center', fontsize=10)  # Combinational logic ax.add_patch(FancyBboxPatch((5, 1.5), 3, 3, boxstyle=\"round,pad=0.05\",              facecolor='#FFF3E0', edgecolor='#F57C00', linewidth=2)) ax.text(6.5, 3, 'Combinational\\nLogic\\n(AND, OR, +, \u00d7)', ha='center', va='center', fontsize=10)  # Register 2 ax.add_patch(FancyBboxPatch((10, 2), 2, 2, boxstyle=\"round,pad=0.05\",              facecolor='#E3F2FD', edgecolor='#1976D2', linewidth=2)) ax.text(11, 3, 'Register B\\n(flip-flops)', ha='center', va='center', fontsize=10)  # Arrows ax.annotate('', xy=(5, 3), xytext=(3, 3),            arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2)) ax.annotate('', xy=(10, 3), xytext=(8, 3),            arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))  # Clock ax.plot([2, 2, 11, 11], [0.5, 1.5, 1.5, 2], 'purple', linewidth=2, linestyle='--') ax.text(6.5, 0.8, 'Clock (synchronizes transfers)', ha='center', fontsize=10, color='purple')  ax.set_xlim(0, 13) ax.set_ylim(0, 5) ax.set_title('RTL Model: Registers + Combinational Logic + Clock', fontsize=12, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show() <p></p> <p></p> <p>Combinational logic has no memory - output depends only on current inputs.</p> <p></p> <p>Sequential logic has memory - uses flip-flops triggered by a clock.</p> In\u00a0[3]: Copied! <pre># Timing diagram: D flip-flop\nfig, axes = plt.subplots(3, 1, figsize=(12, 6), sharex=True)\n\nt = np.linspace(0, 10, 1000)\n\n# Clock\nclk = 0.5 + 0.5 * np.sign(np.sin(2 * np.pi * t))\naxes[0].plot(t, clk, 'b-', linewidth=2)\naxes[0].set_ylabel('CLK', fontsize=11)\naxes[0].set_ylim(-0.2, 1.4)\naxes[0].set_yticks([0, 1])\naxes[0].grid(True, alpha=0.3)\n\n# D input (changes asynchronously)\nd = np.zeros_like(t)\nd[t &gt; 0.7] = 1\nd[t &gt; 2.3] = 0\nd[t &gt; 3.8] = 1\nd[t &gt; 6.5] = 0\nd[t &gt; 8.2] = 1\naxes[1].plot(t, d, 'g-', linewidth=2)\naxes[1].set_ylabel('D (input)', fontsize=11)\naxes[1].set_ylim(-0.2, 1.4)\naxes[1].set_yticks([0, 1])\naxes[1].grid(True, alpha=0.3)\n\n# Q output (samples D at clock rising edges)\nq = np.zeros_like(t)\nrising_edges = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ncurrent_q = 0\nfor i, ti in enumerate(t):\n    # Check for rising edge\n    for edge in rising_edges:\n        if abs(ti - edge) &lt; 0.01:\n            current_q = d[i]\n    q[i] = current_q\n\naxes[2].plot(t, q, 'r-', linewidth=2)\naxes[2].set_ylabel('Q (output)', fontsize=11)\naxes[2].set_xlabel('Time', fontsize=11)\naxes[2].set_ylim(-0.2, 1.4)\naxes[2].set_yticks([0, 1])\naxes[2].grid(True, alpha=0.3)\n\n# Mark rising edges\nfor edge in rising_edges:\n    for ax in axes:\n        ax.axvline(x=edge, color='gray', linestyle=':', alpha=0.5)\n\nplt.suptitle('D Flip-Flop: Q samples D at rising clock edge', fontsize=12, fontweight='bold')\nplt.tight_layout()\nplt.show()\n</pre> # Timing diagram: D flip-flop fig, axes = plt.subplots(3, 1, figsize=(12, 6), sharex=True)  t = np.linspace(0, 10, 1000)  # Clock clk = 0.5 + 0.5 * np.sign(np.sin(2 * np.pi * t)) axes[0].plot(t, clk, 'b-', linewidth=2) axes[0].set_ylabel('CLK', fontsize=11) axes[0].set_ylim(-0.2, 1.4) axes[0].set_yticks([0, 1]) axes[0].grid(True, alpha=0.3)  # D input (changes asynchronously) d = np.zeros_like(t) d[t &gt; 0.7] = 1 d[t &gt; 2.3] = 0 d[t &gt; 3.8] = 1 d[t &gt; 6.5] = 0 d[t &gt; 8.2] = 1 axes[1].plot(t, d, 'g-', linewidth=2) axes[1].set_ylabel('D (input)', fontsize=11) axes[1].set_ylim(-0.2, 1.4) axes[1].set_yticks([0, 1]) axes[1].grid(True, alpha=0.3)  # Q output (samples D at clock rising edges) q = np.zeros_like(t) rising_edges = [1, 2, 3, 4, 5, 6, 7, 8, 9] current_q = 0 for i, ti in enumerate(t):     # Check for rising edge     for edge in rising_edges:         if abs(ti - edge) &lt; 0.01:             current_q = d[i]     q[i] = current_q  axes[2].plot(t, q, 'r-', linewidth=2) axes[2].set_ylabel('Q (output)', fontsize=11) axes[2].set_xlabel('Time', fontsize=11) axes[2].set_ylim(-0.2, 1.4) axes[2].set_yticks([0, 1]) axes[2].grid(True, alpha=0.3)  # Mark rising edges for edge in rising_edges:     for ax in axes:         ax.axvline(x=edge, color='gray', linestyle=':', alpha=0.5)  plt.suptitle('D Flip-Flop: Q samples D at rising clock edge', fontsize=12, fontweight='bold') plt.tight_layout() plt.show() <p></p> <p>A Finite State Machine (FSM) is a circuit that moves between states based on inputs.</p> In\u00a0[4]: Copied! <pre># State machine diagram\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# States as circles\nstates = [\n    ('IDLE', 2, 3, '#E8F5E9'),\n    ('RUN', 6, 3, '#FFF3E0'),\n    ('DONE', 10, 3, '#E3F2FD'),\n]\n\nfor name, x, y, color in states:\n    circle = Circle((x, y), 0.8, facecolor=color, edgecolor='black', linewidth=2)\n    ax.add_patch(circle)\n    ax.text(x, y, name, ha='center', va='center', fontsize=11, fontweight='bold')\n\n# Transitions\n# IDLE -&gt; RUN\nax.annotate('', xy=(5.2, 3.2), xytext=(2.8, 3.2),\n           arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))\nax.text(4, 3.6, 'start=1', ha='center', fontsize=9)\n\n# RUN -&gt; DONE\nax.annotate('', xy=(9.2, 3.2), xytext=(6.8, 3.2),\n           arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))\nax.text(8, 3.6, 'count=0', ha='center', fontsize=9)\n\n# DONE -&gt; IDLE\nax.annotate('', xy=(2.5, 2.2), xytext=(9.5, 2.2),\n           arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2,\n                          connectionstyle='arc3,rad=0.3'))\nax.text(6, 1.3, 'always', ha='center', fontsize=9)\n\n# Self-loops\n# IDLE stays\nax.annotate('', xy=(1.5, 3.6), xytext=(1.3, 3.2),\n           arrowprops=dict(arrowstyle='-&gt;', color='gray', lw=1.5,\n                          connectionstyle='arc3,rad=-0.5'))\nax.text(0.8, 4.2, 'start=0', ha='center', fontsize=8, color='gray')\n\n# RUN stays\nax.annotate('', xy=(5.5, 3.6), xytext=(5.3, 3.2),\n           arrowprops=dict(arrowstyle='-&gt;', color='gray', lw=1.5,\n                          connectionstyle='arc3,rad=-0.5'))\nax.text(4.8, 4.2, 'count&gt;0', ha='center', fontsize=8, color='gray')\n\n# Reset arrow\nax.annotate('', xy=(2, 4.2), xytext=(2, 5),\n           arrowprops=dict(arrowstyle='-&gt;', color='red', lw=2))\nax.text(2, 5.2, 'RESET', ha='center', fontsize=10, color='red', fontweight='bold')\n\nax.set_xlim(0, 12)\nax.set_ylim(0, 6)\nax.set_aspect('equal')\nax.set_title('Simple FSM State Diagram', fontsize=12, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # State machine diagram fig, ax = plt.subplots(figsize=(10, 6))  # States as circles states = [     ('IDLE', 2, 3, '#E8F5E9'),     ('RUN', 6, 3, '#FFF3E0'),     ('DONE', 10, 3, '#E3F2FD'), ]  for name, x, y, color in states:     circle = Circle((x, y), 0.8, facecolor=color, edgecolor='black', linewidth=2)     ax.add_patch(circle)     ax.text(x, y, name, ha='center', va='center', fontsize=11, fontweight='bold')  # Transitions # IDLE -&gt; RUN ax.annotate('', xy=(5.2, 3.2), xytext=(2.8, 3.2),            arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2)) ax.text(4, 3.6, 'start=1', ha='center', fontsize=9)  # RUN -&gt; DONE ax.annotate('', xy=(9.2, 3.2), xytext=(6.8, 3.2),            arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2)) ax.text(8, 3.6, 'count=0', ha='center', fontsize=9)  # DONE -&gt; IDLE ax.annotate('', xy=(2.5, 2.2), xytext=(9.5, 2.2),            arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2,                           connectionstyle='arc3,rad=0.3')) ax.text(6, 1.3, 'always', ha='center', fontsize=9)  # Self-loops # IDLE stays ax.annotate('', xy=(1.5, 3.6), xytext=(1.3, 3.2),            arrowprops=dict(arrowstyle='-&gt;', color='gray', lw=1.5,                           connectionstyle='arc3,rad=-0.5')) ax.text(0.8, 4.2, 'start=0', ha='center', fontsize=8, color='gray')  # RUN stays ax.annotate('', xy=(5.5, 3.6), xytext=(5.3, 3.2),            arrowprops=dict(arrowstyle='-&gt;', color='gray', lw=1.5,                           connectionstyle='arc3,rad=-0.5')) ax.text(4.8, 4.2, 'count&gt;0', ha='center', fontsize=8, color='gray')  # Reset arrow ax.annotate('', xy=(2, 4.2), xytext=(2, 5),            arrowprops=dict(arrowstyle='-&gt;', color='red', lw=2)) ax.text(2, 5.2, 'RESET', ha='center', fontsize=10, color='red', fontweight='bold')  ax.set_xlim(0, 12) ax.set_ylim(0, 6) ax.set_aspect('equal') ax.set_title('Simple FSM State Diagram', fontsize=12, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show() <p></p> <p>A testbench is Verilog code that tests your design.</p> <p></p> <p></p> <p>These constructs are used in the course example projects.</p> <p></p>"},{"location":"notebooks/05_rtl_design_verification/#contents","title":"Contents\u00b6","text":"<ol> <li>What is RTL?</li> <li>Verilog Basics</li> <li>Combinational Logic</li> <li>Sequential Logic</li> <li>State Machines</li> <li>Testbenches</li> <li>Advanced Constructs</li> <li>Common Mistakes</li> </ol>"},{"location":"notebooks/05_rtl_design_verification/#1-what-is-rtl","title":"1. What is RTL?\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#abstraction-levels","title":"Abstraction Levels\u00b6","text":"Level Description Example Behavioral What the circuit does <code>y = a + b</code> RTL Registers + logic <code>always @(posedge clk) y &lt;= a + b;</code> Gate Logic gates AND, OR, XOR, flip-flops Transistor NMOS/PMOS Circuit-level <p>We write at the RTL level and let tools convert to gates.</p>"},{"location":"notebooks/05_rtl_design_verification/#2-verilog-basics","title":"2. Verilog Basics\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#module-structure","title":"Module Structure\u00b6","text":"<pre>module my_module (\n    input  wire       clk,      // Clock\n    input  wire       rst_n,    // Reset (active low)\n    input  wire [7:0] data_in,  // 8-bit input\n    output reg  [7:0] data_out  // 8-bit output\n);\n\n    // Internal signals\n    wire [7:0] intermediate;\n    reg  [7:0] stored;\n    \n    // Logic goes here...\n    \nendmodule\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#data-types","title":"Data Types\u00b6","text":"Type Use Example <code>wire</code> Continuous connections <code>wire a;</code> <code>reg</code> Stores values (not always a register!) <code>reg [7:0] count;</code> <code>integer</code> Simulation only (loop counters) <code>integer i;</code> <code>parameter</code> Constants <code>parameter WIDTH = 8;</code>"},{"location":"notebooks/05_rtl_design_verification/#number-formats","title":"Number Formats\u00b6","text":"<pre>8'b10101010    // 8-bit binary: 170\n8'hAA          // 8-bit hex: 170\n8'd170         // 8-bit decimal: 170\n8'o252         // 8-bit octal: 170\n\n4'b1010        // 4-bit value: 10\n4'bxxxx        // 4-bit unknown\n4'bzzzz        // 4-bit high-impedance\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#3-combinational-logic","title":"3. Combinational Logic\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#method-1-continuous-assignment","title":"Method 1: Continuous Assignment\u00b6","text":"<pre>// Simple gates\nassign y = a &amp; b;           // AND\nassign y = a | b;           // OR\nassign y = a ^ b;           // XOR\nassign y = ~a;              // NOT\n\n// Arithmetic\nassign sum = a + b;\nassign diff = a - b;\n\n// Conditional (mux)\nassign y = sel ? a : b;     // if sel then a else b\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#method-2-always-block-combinational","title":"Method 2: Always Block (combinational)\u00b6","text":"<pre>always @(*) begin           // * means \"all inputs\"\n    case (sel)\n        2'b00: y = a;\n        2'b01: y = b;\n        2'b10: y = c;\n        2'b11: y = d;\n    endcase\nend\n</pre> <p>\u26a0\ufe0f Important: In combinational <code>always</code> blocks, assign to ALL outputs in ALL branches, or you'll create a latch!</p>"},{"location":"notebooks/05_rtl_design_verification/#4-sequential-logic","title":"4. Sequential Logic\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#the-flip-flop-pattern","title":"The Flip-Flop Pattern\u00b6","text":"<pre>always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset values\n        q &lt;= 0;\n    end\n    else begin\n        // Normal operation\n        q &lt;= d;    // Use &lt;= for sequential!\n    end\nend\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#vs","title":"= vs &lt;=\u00b6","text":"Operator Name Use <code>=</code> Blocking Combinational logic <code>&lt;=</code> Non-blocking Sequential logic (flip-flops) <p>Rule: Use <code>&lt;=</code> inside <code>always @(posedge clk)</code> blocks!</p>"},{"location":"notebooks/05_rtl_design_verification/#5-state-machines","title":"5. State Machines\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#fsm-template","title":"FSM Template\u00b6","text":"<pre>// State encoding\nlocalparam IDLE = 2'b00,\n           RUN  = 2'b01,\n           DONE = 2'b10;\n\nreg [1:0] state;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state &lt;= IDLE;\n    end\n    else begin\n        case (state)\n            IDLE: if (start) state &lt;= RUN;\n            RUN:  if (count == 0) state &lt;= DONE;\n            DONE: state &lt;= IDLE;\n            default: state &lt;= IDLE;\n        endcase\n    end\nend\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#6-testbenches","title":"6. Testbenches\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#testbench-template","title":"Testbench Template\u00b6","text":"<pre>`timescale 1ns/1ps\n\nmodule my_module_tb;\n    // Inputs are reg (we drive them)\n    reg clk, rst_n, data_in;\n    \n    // Outputs are wire (DUT drives them)\n    wire data_out;\n    \n    // Instantiate Device Under Test\n    my_module dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n    \n    // Clock generation\n    always #10 clk = ~clk;  // 50 MHz (20ns period)\n    \n    // Test stimulus\n    initial begin\n        $dumpfile(\"waves.vcd\");\n        $dumpvars(0, my_module_tb);\n        \n        // Initialize\n        clk = 0;\n        rst_n = 0;\n        data_in = 0;\n        \n        // Reset\n        #40 rst_n = 1;\n        \n        // Test cases\n        #20 data_in = 1;\n        #20 data_in = 0;\n        \n        #200 $finish;\n    end\nendmodule\n</pre> <p>Note on simulation timing: Testbenches often use faster clocks than the target hardware to speed up simulation. If your design uses <code>parameter CLK_FREQ = 50_000_000</code> (50 MHz), the testbench clock period doesn't need to match\u2014the design behavior is the same. Our examples use 1 MHz in testbenches for faster simulation, but the template above matches the 50 MHz target for clarity.</p>"},{"location":"notebooks/05_rtl_design_verification/#7-simulation-debugging","title":"7. Simulation &amp; Debugging\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#running-simulation","title":"Running Simulation\u00b6","text":"<pre># Compile\niverilog -o sim.vvp my_module.v my_module_tb.v\n\n# Run\nvvp sim.vvp\n\n# View waveforms\ngtkwave waves.vcd\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#debug-prints","title":"Debug Prints\u00b6","text":"<pre>$display(\"Value of x = %d\", x);       // Print once\n$monitor(\"x=%d y=%d\", x, y);          // Print on any change\n$time                                  // Current simulation time\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#linting","title":"Linting\u00b6","text":"<pre># Check for common errors\nverilator --lint-only my_module.v\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#7-advanced-constructs","title":"7. Advanced Constructs\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#generate-blocks","title":"Generate Blocks\u00b6","text":"<p><code>generate</code> lets you create multiple instances or conditional hardware:</p> <pre>// Create 4 identical synchronizers\ngenvar i;\ngenerate\n    for (i = 0; i &lt; 4; i = i + 1) begin : sync_gen\n        reg [1:0] sync;\n        always @(posedge clk) begin\n            sync &lt;= {sync[0], input_bus[i]};\n        end\n        assign synced[i] = sync[1];\n    end\nendgenerate\n</pre> <p>Used in: <code>pocket_synth.v</code> for key synchronizers.</p>"},{"location":"notebooks/05_rtl_design_verification/#system-functions","title":"System Functions\u00b6","text":"<p>$clog2 - Calculate bits needed for a value:</p> <pre>// How many bits to count to 1000?\nlocalparam COUNT_MAX = 1000;\nlocalparam WIDTH = $clog2(COUNT_MAX + 1);  // = 10 bits\n\nreg [WIDTH-1:0] counter;  // 10-bit counter\n</pre> <p>Used in: <code>uart_tx.v</code>, <code>debounce.v</code> for counter sizing.</p>"},{"location":"notebooks/05_rtl_design_verification/#localparam-vs-parameter","title":"Localparam vs Parameter\u00b6","text":"<pre>parameter  CLK_FREQ = 50_000_000;  // Can be overridden when instantiating\nlocalparam HALF = CLK_FREQ / 2;    // Calculated, cannot be overridden\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#8-common-mistakes","title":"8. Common Mistakes\u00b6","text":""},{"location":"notebooks/05_rtl_design_verification/#unintentional-latches","title":"\u274c Unintentional Latches\u00b6","text":"<pre>// BAD: Missing else creates a latch!\nalways @(*) begin\n    if (sel)\n        y = a;\n    // What about when sel=0? Latch inferred!\nend\n\n// GOOD: All cases covered\nalways @(*) begin\n    if (sel)\n        y = a;\n    else\n        y = b;\nend\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#mixing-blockingnon-blocking","title":"\u274c Mixing Blocking/Non-Blocking\u00b6","text":"<pre>// BAD: Using = in sequential logic\nalways @(posedge clk)\n    q = d;    // Should be &lt;=\n\n// GOOD\nalways @(posedge clk)\n    q &lt;= d;\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#incomplete-sensitivity-list","title":"\u274c Incomplete Sensitivity List\u00b6","text":"<pre>// BAD: Missing 'b' in sensitivity list\nalways @(a)\n    y = a &amp; b;    // Won't update when b changes!\n\n// GOOD: Use @(*) for combinational\nalways @(*)\n    y = a &amp; b;\n</pre>"},{"location":"notebooks/05_rtl_design_verification/#summary","title":"Summary\u00b6","text":"<ul> <li>RTL = Registers + Combinational Logic + Clock</li> <li>Use <code>wire</code> + <code>assign</code> for combinational</li> <li>Use <code>reg</code> + <code>always @(posedge clk)</code> for sequential</li> <li>FSMs organize sequential behavior</li> <li>Testbenches verify your design before synthesis</li> </ul>"},{"location":"notebooks/05_rtl_design_verification/#homework","title":"Homework\u00b6","text":"<ol> <li>Write/modify Verilog for your project</li> <li>Create a testbench</li> <li>Simulate and view waveforms in GTKWave</li> <li>Run linter, fix any warnings</li> </ol>"},{"location":"notebooks/06_synthesis_physical_design/","title":"Synthesis & Physical Design","text":"Synthesis &amp; Physical Design <p>Week 3, Session 2 \u2014 Fab Futures</p> In\u00a0[1]: Copied! <pre># Setup\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import FancyBboxPatch, Rectangle, FancyArrowPatch\nimport numpy as np\n\nprint(\"Setup complete.\")\n</pre> # Setup import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.patches import FancyBboxPatch, Rectangle, FancyArrowPatch import numpy as np  print(\"Setup complete.\") <pre>Setup complete.\n</pre> <p></p> <p>Synthesis converts RTL code into a netlist of logic gates.</p> <pre><code>Verilog RTL  \u2192  [Synthesis]  \u2192  Gate Netlist  \u2192  [Place &amp; Route]  \u2192  GDS\n</code></pre> In\u00a0[2]: Copied! <pre># Synthesis flow visualization\nfig, ax = plt.subplots(figsize=(14, 6))\n\nstages = [\n    ('RTL\\nVerilog', '#E8F5E9', 'assign y = a &amp; b;\\nalways @(posedge clk)...'),\n    ('Generic\\nNetlist', '#FFF3E0', 'AND, OR, FF\\n(technology independent)'),\n    ('Mapped\\nNetlist', '#E3F2FD', 'sky130_fd_sc_hd__and2_1\\nsky130_fd_sc_hd__dfxtp_1'),\n    ('Optimized\\nNetlist', '#F3E5F5', 'Timing-optimized\\nArea-optimized'),\n]\n\nfor i, (name, color, desc) in enumerate(stages):\n    x = i * 3.5 + 0.5\n    ax.add_patch(FancyBboxPatch((x, 1), 2.5, 3, boxstyle=\"round,pad=0.1\",\n                 facecolor=color, edgecolor='black', linewidth=2))\n    ax.text(x + 1.25, 3.2, name, ha='center', va='center', fontsize=11, fontweight='bold')\n    ax.text(x + 1.25, 1.8, desc, ha='center', va='center', fontsize=8, style='italic')\n    \n    if i &lt; len(stages) - 1:\n        ax.annotate('', xy=(x + 2.8, 2.5), xytext=(x + 2.5, 2.5),\n                   arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))\n\n# Tool labels\nax.text(3.5, 0.5, 'Yosys', ha='center', fontsize=10, color='blue', fontweight='bold')\nax.text(7, 0.5, 'abc', ha='center', fontsize=10, color='blue', fontweight='bold')\nax.text(10.5, 0.5, 'Timing opt', ha='center', fontsize=10, color='blue', fontweight='bold')\n\nax.set_xlim(0, 14)\nax.set_ylim(0, 5)\nax.set_title('Logic Synthesis Flow', fontsize=14, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Synthesis flow visualization fig, ax = plt.subplots(figsize=(14, 6))  stages = [     ('RTL\\nVerilog', '#E8F5E9', 'assign y = a &amp; b;\\nalways @(posedge clk)...'),     ('Generic\\nNetlist', '#FFF3E0', 'AND, OR, FF\\n(technology independent)'),     ('Mapped\\nNetlist', '#E3F2FD', 'sky130_fd_sc_hd__and2_1\\nsky130_fd_sc_hd__dfxtp_1'),     ('Optimized\\nNetlist', '#F3E5F5', 'Timing-optimized\\nArea-optimized'), ]  for i, (name, color, desc) in enumerate(stages):     x = i * 3.5 + 0.5     ax.add_patch(FancyBboxPatch((x, 1), 2.5, 3, boxstyle=\"round,pad=0.1\",                  facecolor=color, edgecolor='black', linewidth=2))     ax.text(x + 1.25, 3.2, name, ha='center', va='center', fontsize=11, fontweight='bold')     ax.text(x + 1.25, 1.8, desc, ha='center', va='center', fontsize=8, style='italic')          if i &lt; len(stages) - 1:         ax.annotate('', xy=(x + 2.8, 2.5), xytext=(x + 2.5, 2.5),                    arrowprops=dict(arrowstyle='-&gt;', color='black', lw=2))  # Tool labels ax.text(3.5, 0.5, 'Yosys', ha='center', fontsize=10, color='blue', fontweight='bold') ax.text(7, 0.5, 'abc', ha='center', fontsize=10, color='blue', fontweight='bold') ax.text(10.5, 0.5, 'Timing opt', ha='center', fontsize=10, color='blue', fontweight='bold')  ax.set_xlim(0, 14) ax.set_ylim(0, 5) ax.set_title('Logic Synthesis Flow', fontsize=14, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show() <p></p> <p></p> <p>A standard cell library provides pre-designed, pre-characterized logic gates.</p> In\u00a0[3]: Copied! <pre># Standard cell layout concept\nfig, ax = plt.subplots(figsize=(14, 6))\n\n# Draw cell row\ncells = [\n    ('INV', 1, '#FFCDD2'),\n    ('AND2', 2, '#C8E6C9'),\n    ('DFF', 3, '#BBDEFB'),\n    ('OR2', 2, '#FFE0B2'),\n    ('INV', 1, '#FFCDD2'),\n    ('NAND2', 2, '#E1BEE7'),\n    ('DFF', 3, '#BBDEFB'),\n]\n\nx = 0.5\nfor name, width, color in cells:\n    # Cell body\n    ax.add_patch(Rectangle((x, 1), width, 3, facecolor=color, edgecolor='black', linewidth=2))\n    ax.text(x + width/2, 2.5, name, ha='center', va='center', fontsize=10, fontweight='bold')\n    x += width + 0.1\n\n# Power rails\nax.add_patch(Rectangle((0, 4), x + 0.5, 0.4, facecolor='#F44336', edgecolor='black'))\nax.text(x/2, 4.2, 'VDD', ha='center', va='center', fontsize=10, color='white', fontweight='bold')\n\nax.add_patch(Rectangle((0, 0.6), x + 0.5, 0.4, facecolor='#2196F3', edgecolor='black'))\nax.text(x/2, 0.8, 'GND', ha='center', va='center', fontsize=10, color='white', fontweight='bold')\n\n# Annotations\nax.annotate('', xy=(0.5, 5.5), xytext=(0.5, 4.5),\n           arrowprops=dict(arrowstyle='&lt;-&gt;', color='gray', lw=2))\nax.text(0.2, 5, 'Cell\\nheight\\n(fixed)', fontsize=8, ha='center')\n\nax.annotate('', xy=(0.5, 0.3), xytext=(2.5, 0.3),\n           arrowprops=dict(arrowstyle='&lt;-&gt;', color='gray', lw=2))\nax.text(1.5, 0, 'Cell width (varies)', fontsize=8, ha='center')\n\nax.set_xlim(-0.5, x + 1)\nax.set_ylim(-0.5, 6)\nax.set_title('Standard Cell Row', fontsize=14, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"Standard cells have fixed height and variable width.\")\nprint(\"They're placed in rows and share power rails.\")\n</pre> # Standard cell layout concept fig, ax = plt.subplots(figsize=(14, 6))  # Draw cell row cells = [     ('INV', 1, '#FFCDD2'),     ('AND2', 2, '#C8E6C9'),     ('DFF', 3, '#BBDEFB'),     ('OR2', 2, '#FFE0B2'),     ('INV', 1, '#FFCDD2'),     ('NAND2', 2, '#E1BEE7'),     ('DFF', 3, '#BBDEFB'), ]  x = 0.5 for name, width, color in cells:     # Cell body     ax.add_patch(Rectangle((x, 1), width, 3, facecolor=color, edgecolor='black', linewidth=2))     ax.text(x + width/2, 2.5, name, ha='center', va='center', fontsize=10, fontweight='bold')     x += width + 0.1  # Power rails ax.add_patch(Rectangle((0, 4), x + 0.5, 0.4, facecolor='#F44336', edgecolor='black')) ax.text(x/2, 4.2, 'VDD', ha='center', va='center', fontsize=10, color='white', fontweight='bold')  ax.add_patch(Rectangle((0, 0.6), x + 0.5, 0.4, facecolor='#2196F3', edgecolor='black')) ax.text(x/2, 0.8, 'GND', ha='center', va='center', fontsize=10, color='white', fontweight='bold')  # Annotations ax.annotate('', xy=(0.5, 5.5), xytext=(0.5, 4.5),            arrowprops=dict(arrowstyle='&lt;-&gt;', color='gray', lw=2)) ax.text(0.2, 5, 'Cell\\nheight\\n(fixed)', fontsize=8, ha='center')  ax.annotate('', xy=(0.5, 0.3), xytext=(2.5, 0.3),            arrowprops=dict(arrowstyle='&lt;-&gt;', color='gray', lw=2)) ax.text(1.5, 0, 'Cell width (varies)', fontsize=8, ha='center')  ax.set_xlim(-0.5, x + 1) ax.set_ylim(-0.5, 6) ax.set_title('Standard Cell Row', fontsize=14, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show()  print(\"Standard cells have fixed height and variable width.\") print(\"They're placed in rows and share power rails.\") <pre>Standard cells have fixed height and variable width.\nThey're placed in rows and share power rails.\n</pre> <p></p> <p>Place and Route (P&amp;R) takes the synthesized netlist and creates physical layout.</p> In\u00a0[4]: Copied! <pre># P&amp;R stages visualization\nfig, axes = plt.subplots(2, 3, figsize=(14, 8))\naxes = axes.flatten()\n\ntitles = ['1. Floorplan', '2. Power Grid', '3. Placement', \n          '4. Clock Tree', '5. Routing', '6. Final Layout']\n\nfor idx, (ax, title) in enumerate(zip(axes, titles)):\n    # Chip boundary\n    ax.add_patch(Rectangle((0, 0), 10, 10, facecolor='#F5F5F5', edgecolor='black', linewidth=2))\n    \n    if idx == 0:  # Floorplan\n        ax.add_patch(Rectangle((1, 1), 8, 8, facecolor='#E8F5E9', edgecolor='green', linewidth=2, linestyle='--'))\n        ax.text(5, 5, 'Core\\nArea', ha='center', va='center', fontsize=10)\n        # I/O pads\n        for i in range(4):\n            ax.add_patch(Rectangle((0, 2 + i*1.5), 0.8, 1, facecolor='#BBDEFB'))\n            ax.add_patch(Rectangle((9.2, 2 + i*1.5), 0.8, 1, facecolor='#BBDEFB'))\n            \n    elif idx == 1:  # Power\n        for i in range(6):\n            ax.plot([1, 9], [1.5 + i*1.3, 1.5 + i*1.3], 'r-', linewidth=2)\n        for i in range(6):\n            ax.plot([1.5 + i*1.3, 1.5 + i*1.3], [1, 9], 'b-', linewidth=2)\n        ax.text(5, 0.5, 'VDD (red) / GND (blue)', ha='center', fontsize=8)\n            \n    elif idx == 2:  # Placement\n        np.random.seed(42)\n        for i in range(30):\n            x, y = np.random.uniform(1, 8), np.random.uniform(1, 8)\n            w = np.random.uniform(0.3, 0.8)\n            ax.add_patch(Rectangle((x, y), w, 0.4, facecolor='#C8E6C9', edgecolor='black'))\n            \n    elif idx == 3:  # Clock tree\n        ax.plot([5, 5], [1, 5], 'purple', linewidth=2)\n        ax.plot([5, 3], [5, 7], 'purple', linewidth=2)\n        ax.plot([5, 7], [5, 7], 'purple', linewidth=2)\n        ax.plot([3, 2], [7, 8], 'purple', linewidth=1.5)\n        ax.plot([3, 4], [7, 8], 'purple', linewidth=1.5)\n        ax.plot([7, 6], [7, 8], 'purple', linewidth=1.5)\n        ax.plot([7, 8], [7, 8], 'purple', linewidth=1.5)\n        ax.plot([5], [1], 'g^', markersize=10)\n        \n    elif idx == 4:  # Routing\n        np.random.seed(42)\n        for i in range(30):\n            x, y = np.random.uniform(1, 8), np.random.uniform(1, 8)\n            w = np.random.uniform(0.3, 0.8)\n            ax.add_patch(Rectangle((x, y), w, 0.4, facecolor='#C8E6C9', edgecolor='black'))\n        # Some routes\n        for i in range(15):\n            x1, y1 = np.random.uniform(1, 8), np.random.uniform(1, 8)\n            x2 = x1 + np.random.uniform(-2, 2)\n            y2 = y1 + np.random.uniform(-2, 2)\n            ax.plot([x1, x2, x2], [y1, y1, y2], 'b-', linewidth=0.5, alpha=0.5)\n            \n    elif idx == 5:  # Final\n        # Filled area\n        ax.add_patch(Rectangle((1, 1), 8, 8, facecolor='#E3F2FD', edgecolor='black'))\n        # Cells\n        np.random.seed(42)\n        for i in range(30):\n            x, y = np.random.uniform(1, 8), np.random.uniform(1, 8)\n            w = np.random.uniform(0.3, 0.8)\n            ax.add_patch(Rectangle((x, y), w, 0.4, facecolor='#C8E6C9', edgecolor='black'))\n    \n    ax.set_xlim(-0.5, 10.5)\n    ax.set_ylim(-0.5, 10.5)\n    ax.set_aspect('equal')\n    ax.set_title(title, fontsize=11, fontweight='bold')\n    ax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # P&amp;R stages visualization fig, axes = plt.subplots(2, 3, figsize=(14, 8)) axes = axes.flatten()  titles = ['1. Floorplan', '2. Power Grid', '3. Placement',            '4. Clock Tree', '5. Routing', '6. Final Layout']  for idx, (ax, title) in enumerate(zip(axes, titles)):     # Chip boundary     ax.add_patch(Rectangle((0, 0), 10, 10, facecolor='#F5F5F5', edgecolor='black', linewidth=2))          if idx == 0:  # Floorplan         ax.add_patch(Rectangle((1, 1), 8, 8, facecolor='#E8F5E9', edgecolor='green', linewidth=2, linestyle='--'))         ax.text(5, 5, 'Core\\nArea', ha='center', va='center', fontsize=10)         # I/O pads         for i in range(4):             ax.add_patch(Rectangle((0, 2 + i*1.5), 0.8, 1, facecolor='#BBDEFB'))             ax.add_patch(Rectangle((9.2, 2 + i*1.5), 0.8, 1, facecolor='#BBDEFB'))                  elif idx == 1:  # Power         for i in range(6):             ax.plot([1, 9], [1.5 + i*1.3, 1.5 + i*1.3], 'r-', linewidth=2)         for i in range(6):             ax.plot([1.5 + i*1.3, 1.5 + i*1.3], [1, 9], 'b-', linewidth=2)         ax.text(5, 0.5, 'VDD (red) / GND (blue)', ha='center', fontsize=8)                  elif idx == 2:  # Placement         np.random.seed(42)         for i in range(30):             x, y = np.random.uniform(1, 8), np.random.uniform(1, 8)             w = np.random.uniform(0.3, 0.8)             ax.add_patch(Rectangle((x, y), w, 0.4, facecolor='#C8E6C9', edgecolor='black'))                  elif idx == 3:  # Clock tree         ax.plot([5, 5], [1, 5], 'purple', linewidth=2)         ax.plot([5, 3], [5, 7], 'purple', linewidth=2)         ax.plot([5, 7], [5, 7], 'purple', linewidth=2)         ax.plot([3, 2], [7, 8], 'purple', linewidth=1.5)         ax.plot([3, 4], [7, 8], 'purple', linewidth=1.5)         ax.plot([7, 6], [7, 8], 'purple', linewidth=1.5)         ax.plot([7, 8], [7, 8], 'purple', linewidth=1.5)         ax.plot([5], [1], 'g^', markersize=10)              elif idx == 4:  # Routing         np.random.seed(42)         for i in range(30):             x, y = np.random.uniform(1, 8), np.random.uniform(1, 8)             w = np.random.uniform(0.3, 0.8)             ax.add_patch(Rectangle((x, y), w, 0.4, facecolor='#C8E6C9', edgecolor='black'))         # Some routes         for i in range(15):             x1, y1 = np.random.uniform(1, 8), np.random.uniform(1, 8)             x2 = x1 + np.random.uniform(-2, 2)             y2 = y1 + np.random.uniform(-2, 2)             ax.plot([x1, x2, x2], [y1, y1, y2], 'b-', linewidth=0.5, alpha=0.5)                  elif idx == 5:  # Final         # Filled area         ax.add_patch(Rectangle((1, 1), 8, 8, facecolor='#E3F2FD', edgecolor='black'))         # Cells         np.random.seed(42)         for i in range(30):             x, y = np.random.uniform(1, 8), np.random.uniform(1, 8)             w = np.random.uniform(0.3, 0.8)             ax.add_patch(Rectangle((x, y), w, 0.4, facecolor='#C8E6C9', edgecolor='black'))          ax.set_xlim(-0.5, 10.5)     ax.set_ylim(-0.5, 10.5)     ax.set_aspect('equal')     ax.set_title(title, fontsize=11, fontweight='bold')     ax.axis('off')  plt.tight_layout() plt.show() <p></p> <p>Clock Tree Synthesis (CTS) builds a balanced distribution network for the clock signal.</p> <p></p> <p>Static Timing Analysis (STA) checks if your design meets timing without simulation.</p> In\u00a0[5]: Copied! <pre># Setup timing diagram\nfig, axes = plt.subplots(4, 1, figsize=(12, 8), sharex=True)\n\nt = np.linspace(0, 20, 1000)\n\n# Clock\nclk = 0.5 + 0.5 * np.sign(np.sin(2 * np.pi * t / 10))\naxes[0].plot(t, clk, 'b-', linewidth=2)\naxes[0].set_ylabel('Clock', fontsize=10)\naxes[0].axvline(x=5, color='green', linestyle='--', label='Launch edge')\naxes[0].axvline(x=15, color='red', linestyle='--', label='Capture edge')\naxes[0].legend(loc='right')\n\n# Launch data\nd_launch = np.zeros_like(t)\nd_launch[t &gt; 5.5] = 1  # Data changes after clk-to-q delay\naxes[1].plot(t, d_launch, 'g-', linewidth=2)\naxes[1].set_ylabel('Launch FF\\nOutput', fontsize=10)\naxes[1].annotate('', xy=(5.5, 0.5), xytext=(5, 0.5),\n                arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=1.5))\naxes[1].text(5.25, 0.7, 'Tclk\u2192q', fontsize=9, ha='center', color='green')\n\n# After combinational logic\nd_capture = np.zeros_like(t)\nd_capture[t &gt; 12] = 1  # Data arrives after logic delay\naxes[2].plot(t, d_capture, 'orange', linewidth=2)\naxes[2].set_ylabel('Capture FF\\nInput', fontsize=10)\naxes[2].annotate('', xy=(12, 0.5), xytext=(5.5, 0.5),\n                arrowprops=dict(arrowstyle='&lt;-&gt;', color='orange', lw=1.5))\naxes[2].text(8.75, 0.7, 'Tlogic', fontsize=9, ha='center', color='orange')\n\n# Setup requirement\naxes[3].axvspan(14, 15, alpha=0.3, color='red', label='Setup window')\naxes[3].axvspan(15, 15.5, alpha=0.3, color='blue', label='Hold window')\naxes[3].plot([12, 12, 20], [0, 1, 1], 'orange', linewidth=2)\naxes[3].set_ylabel('Data at\\nCapture', fontsize=10)\naxes[3].set_xlabel('Time (ns)', fontsize=10)\naxes[3].legend(loc='right')\n\n# Slack annotation\naxes[3].annotate('', xy=(14, 0.5), xytext=(12, 0.5),\n                arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=2))\naxes[3].text(13, 0.7, 'Slack\\n(positive!)', fontsize=10, ha='center', color='green', fontweight='bold')\n\nfor ax in axes:\n    ax.set_ylim(-0.2, 1.4)\n    ax.grid(True, alpha=0.3)\n    ax.set_xlim(0, 20)\n\nplt.suptitle('Setup Timing Check', fontsize=12, fontweight='bold')\nplt.tight_layout()\nplt.show()\n</pre> # Setup timing diagram fig, axes = plt.subplots(4, 1, figsize=(12, 8), sharex=True)  t = np.linspace(0, 20, 1000)  # Clock clk = 0.5 + 0.5 * np.sign(np.sin(2 * np.pi * t / 10)) axes[0].plot(t, clk, 'b-', linewidth=2) axes[0].set_ylabel('Clock', fontsize=10) axes[0].axvline(x=5, color='green', linestyle='--', label='Launch edge') axes[0].axvline(x=15, color='red', linestyle='--', label='Capture edge') axes[0].legend(loc='right')  # Launch data d_launch = np.zeros_like(t) d_launch[t &gt; 5.5] = 1  # Data changes after clk-to-q delay axes[1].plot(t, d_launch, 'g-', linewidth=2) axes[1].set_ylabel('Launch FF\\nOutput', fontsize=10) axes[1].annotate('', xy=(5.5, 0.5), xytext=(5, 0.5),                 arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=1.5)) axes[1].text(5.25, 0.7, 'Tclk\u2192q', fontsize=9, ha='center', color='green')  # After combinational logic d_capture = np.zeros_like(t) d_capture[t &gt; 12] = 1  # Data arrives after logic delay axes[2].plot(t, d_capture, 'orange', linewidth=2) axes[2].set_ylabel('Capture FF\\nInput', fontsize=10) axes[2].annotate('', xy=(12, 0.5), xytext=(5.5, 0.5),                 arrowprops=dict(arrowstyle='&lt;-&gt;', color='orange', lw=1.5)) axes[2].text(8.75, 0.7, 'Tlogic', fontsize=9, ha='center', color='orange')  # Setup requirement axes[3].axvspan(14, 15, alpha=0.3, color='red', label='Setup window') axes[3].axvspan(15, 15.5, alpha=0.3, color='blue', label='Hold window') axes[3].plot([12, 12, 20], [0, 1, 1], 'orange', linewidth=2) axes[3].set_ylabel('Data at\\nCapture', fontsize=10) axes[3].set_xlabel('Time (ns)', fontsize=10) axes[3].legend(loc='right')  # Slack annotation axes[3].annotate('', xy=(14, 0.5), xytext=(12, 0.5),                 arrowprops=dict(arrowstyle='&lt;-&gt;', color='green', lw=2)) axes[3].text(13, 0.7, 'Slack\\n(positive!)', fontsize=10, ha='center', color='green', fontweight='bold')  for ax in axes:     ax.set_ylim(-0.2, 1.4)     ax.grid(True, alpha=0.3)     ax.set_xlim(0, 20)  plt.suptitle('Setup Timing Check', fontsize=12, fontweight='bold') plt.tight_layout() plt.show() <p></p>"},{"location":"notebooks/06_synthesis_physical_design/#contents","title":"Contents\u00b6","text":"<ol> <li>Synthesis Overview</li> <li>Yosys Synthesis</li> <li>Standard Cells</li> <li>Place and Route</li> <li>Timing Analysis</li> <li>Power Analysis</li> <li>The Full Flow</li> </ol>"},{"location":"notebooks/06_synthesis_physical_design/#1-what-is-synthesis","title":"1. What is Synthesis?\u00b6","text":""},{"location":"notebooks/06_synthesis_physical_design/#the-synthesis-process","title":"The Synthesis Process\u00b6","text":"Step What Happens 1. Parsing Read and check Verilog syntax 2. Elaboration Expand hierarchy, resolve parameters 3. Logic Optimization Simplify boolean expressions 4. Technology Mapping Map to standard cells from PDK 5. Timing Optimization Meet timing constraints"},{"location":"notebooks/06_synthesis_physical_design/#2-logic-synthesis-with-yosys","title":"2. Logic Synthesis with Yosys\u00b6","text":""},{"location":"notebooks/06_synthesis_physical_design/#basic-yosys-commands","title":"Basic Yosys Commands\u00b6","text":"<pre># Read Verilog\nread_verilog my_design.v\n\n# Elaborate hierarchy\nhierarchy -check -top my_design\n\n# Synthesize to generic gates\nsynth -top my_design\n\n# Map to Sky130 cells\ndfflibmap -liberty sky130_fd_sc_hd__tt_025C_1v80.lib\nabc -liberty sky130_fd_sc_hd__tt_025C_1v80.lib\n\n# Clean up\nclean\n\n# Write output\nwrite_verilog -noattr synth.v\n</pre>"},{"location":"notebooks/06_synthesis_physical_design/#running-yosys","title":"Running Yosys\u00b6","text":"<pre># Interactive\nyosys\n\n# Script\nyosys -s synth.tcl\n\n# One-liner\nyosys -p \"read_verilog design.v; synth -top top; write_verilog out.v\"\n</pre>"},{"location":"notebooks/06_synthesis_physical_design/#what-to-check-after-synthesis","title":"What to Check After Synthesis\u00b6","text":"Check What it Means Warnings Undriven wires, width mismatches Latches \"inferred latch\" = usually a bug! Cell count How big is your design? Flip-flop count Register bits <pre><code>=== my_design ===\n\n   Number of wires:                 45\n   Number of wire bits:            128\n   Number of cells:                 67\n     sky130_fd_sc_hd__and2_1         8\n     sky130_fd_sc_hd__dfxtp_1       16\n     sky130_fd_sc_hd__inv_1         12\n     sky130_fd_sc_hd__mux2_1         4\n     ...\n</code></pre>"},{"location":"notebooks/06_synthesis_physical_design/#example-synthesizing-fortune-teller","title":"Example: Synthesizing Fortune Teller\u00b6","text":"<p>Let's look at real synthesis output for the <code>fortune_teller</code> example. This design includes:</p> <ul> <li>8-bit LFSR for random number generation (8 flip-flops)</li> <li>4-state FSM for controlling the sequence (2 flip-flops + control logic)</li> <li>160-byte ROM for storing 8 fortunes (synthesizes to muxes and logic)</li> <li>debounce module with 19-bit counter for 10ms @ 50MHz (~23 flip-flops)</li> <li>uart_tx module with baud rate counter (~24 flip-flops)</li> </ul> <pre># Synthesize fortune_teller with Yosys\ncd /path/to/examples/fortune_teller\nyosys -p \"\n  read_verilog -I../lib fortune_teller.v ../lib/debounce.v ../lib/uart_tx.v\n  hierarchy -check -top fortune_teller\n  synth -top fortune_teller\n  dfflibmap -liberty \\$PDK_ROOT/sky130A/libs.ref/sky130_fd_sc_hd/lib/sky130_fd_sc_hd__tt_025C_1v80.lib\n  abc -liberty \\$PDK_ROOT/sky130A/libs.ref/sky130_fd_sc_hd/lib/sky130_fd_sc_hd__tt_025C_1v80.lib\n  clean\n  stat\n\"\n</pre> <p>Synthesis report (actual output):</p> <pre><code>=== fortune_teller ===\n\n   Number of wires:                512\n   Number of wire bits:           1847\n   Number of public wires:          38\n   Number of public wire bits:     182\n   Number of memories:               0\n   Number of memory bits:            0\n   Number of processes:              0\n   Number of cells:                487\n     sky130_fd_sc_hd__a21o_1         8\n     sky130_fd_sc_hd__a21oi_1       12\n     sky130_fd_sc_hd__a22o_1         6\n     sky130_fd_sc_hd__and2_1        14\n     sky130_fd_sc_hd__and3_1         4\n     sky130_fd_sc_hd__and4_1         2\n     sky130_fd_sc_hd__clkinv_1      28\n     sky130_fd_sc_hd__dfxtp_1       74\n     sky130_fd_sc_hd__mux2_1        89\n     sky130_fd_sc_hd__nand2_1       36\n     sky130_fd_sc_hd__nand3_1        8\n     sky130_fd_sc_hd__nor2_1        42\n     sky130_fd_sc_hd__nor3_1         6\n     sky130_fd_sc_hd__o21a_1        11\n     sky130_fd_sc_hd__o21ai_1       18\n     sky130_fd_sc_hd__or2_1         22\n     sky130_fd_sc_hd__or3_1          4\n     sky130_fd_sc_hd__xnor2_1       56\n     sky130_fd_sc_hd__xor2_1        47\n</code></pre> <p>What this tells us:</p> Metric Value Notes Total cells 487 Within our ~200-500 target Flip-flops 74 <code>dfxtp_1</code> = D flip-flop, positive edge Muxes 89 Mostly from ROM address decoding XOR/XNOR 103 LFSR feedback, counter comparisons Combinational 413 Everything except flip-flops <p>The 160-byte ROM synthesized to muxes and logic gates - no dedicated memory cells. For larger memories, you'd use OpenRAM or hard macros.</p> <p>Breakdown by module (approximate):</p> Module Flip-flops Purpose fortune_teller 27 LFSR (8), FSM (2), fortune_sel (3), char_idx (5), current_char (8), send_valid (1) debounce 23 counter (19), sync (1), stable (1), prev (1), pressed (1) uart_tx 24 state (2), clk_ctr (9), bit_idx (3), shift_reg (8), ready (1), tx (1) <p>No latches - this is what we want. If you see \"inferred latch\" warnings, that's usually a bug in your RTL (missing else clause or incomplete case statement).</p>"},{"location":"notebooks/06_synthesis_physical_design/#3-standard-cells","title":"3. Standard Cells\u00b6","text":""},{"location":"notebooks/06_synthesis_physical_design/#cell-naming-convention-sky130","title":"Cell Naming Convention (Sky130)\u00b6","text":"<p><code>sky130_fd_sc_hd__and2_2</code></p> Part Meaning <code>sky130</code> Process <code>fd</code> Foundry <code>sc</code> Standard cell <code>hd</code> High density library <code>and2</code> 2-input AND gate <code>2</code> Drive strength (higher = faster, bigger)"},{"location":"notebooks/06_synthesis_physical_design/#common-cell-types","title":"Common Cell Types\u00b6","text":"Cell Function <code>inv</code> Inverter <code>and2</code>, <code>and3</code>, <code>and4</code> AND gates <code>or2</code>, <code>or3</code> OR gates <code>nand2</code>, <code>nor2</code> NAND/NOR gates <code>xor2</code> XOR gate <code>mux2</code> 2:1 multiplexer <code>dfxtp</code> D flip-flop (positive edge) <code>dfrtp</code> D flip-flop with reset <code>buf</code> Buffer"},{"location":"notebooks/06_synthesis_physical_design/#4-place-and-route","title":"4. Place and Route\u00b6","text":""},{"location":"notebooks/06_synthesis_physical_design/#pr-steps","title":"P&amp;R Steps\u00b6","text":"Step Description Floorplanning Define chip area, place I/O pads Power Planning Create VDD/GND grid Placement Position standard cells Clock Tree Synthesis Build clock distribution Routing Connect cells with metal wires Fill Add filler cells and metal fill"},{"location":"notebooks/06_synthesis_physical_design/#5-clock-tree-synthesis","title":"5. Clock Tree Synthesis\u00b6","text":""},{"location":"notebooks/06_synthesis_physical_design/#goals","title":"Goals\u00b6","text":"Goal Why Low skew All flip-flops see clock at nearly same time Low latency Minimize clock delay Low power Clock toggles every cycle - big power consumer"},{"location":"notebooks/06_synthesis_physical_design/#clock-tree-structure","title":"Clock Tree Structure\u00b6","text":"<ul> <li>Clock buffers amplify the signal</li> <li>H-tree or mesh balances delay</li> <li>Tools automatically size and place buffers</li> </ul>"},{"location":"notebooks/06_synthesis_physical_design/#6-static-timing-analysis","title":"6. Static Timing Analysis\u00b6","text":""},{"location":"notebooks/06_synthesis_physical_design/#key-concepts","title":"Key Concepts\u00b6","text":"Term Meaning Setup time Data must be stable BEFORE clock edge Hold time Data must be stable AFTER clock edge Slack Margin (positive = good, negative = violation) Critical path Longest delay path (determines max frequency)"},{"location":"notebooks/06_synthesis_physical_design/#timing-path","title":"Timing Path\u00b6","text":"<pre><code>Launch FF \u2192 Combinational Logic \u2192 Capture FF\n   |                                    |\n   |\u2190 \u2500 \u2500 \u2500 Clock Period \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2192 |\n</code></pre> <p>Setup check: Data must arrive before capture clock edge</p> <p>$$T_{clock} &gt; T_{clk\u2192q} + T_{logic} + T_{setup}$$</p>"},{"location":"notebooks/06_synthesis_physical_design/#7-reading-reports","title":"7. Reading Reports\u00b6","text":""},{"location":"notebooks/06_synthesis_physical_design/#timing-report-example","title":"Timing Report Example\u00b6","text":"<pre><code>Startpoint: data_reg[0] (rising edge-triggered flip-flop clocked by clk)\nEndpoint: out_reg[0] (rising edge-triggered flip-flop clocked by clk)\nPath Group: clk\nPath Type: max (setup check)\n\n  Point                                    Incr      Path\n  --------------------------------------------------------\n  clock clk (rise edge)                    0.00      0.00\n  clock network delay                      0.52      0.52\n  data_reg[0]/CLK (sky130_fd_sc_hd__dfxtp_1)\n                                           0.00      0.52 r\n  data_reg[0]/Q (sky130_fd_sc_hd__dfxtp_1)\n                                           0.35      0.87 r\n  U15/Y (sky130_fd_sc_hd__and2_1)          0.18      1.05 r\n  U16/Y (sky130_fd_sc_hd__inv_1)           0.08      1.13 f\n  out_reg[0]/D (sky130_fd_sc_hd__dfxtp_1)\n                                           0.00      1.13 f\n  data arrival time                                  1.13\n\n  clock clk (rise edge)                   20.00     20.00\n  clock network delay                      0.52     20.52\n  out_reg[0]/CLK (sky130_fd_sc_hd__dfxtp_1)\n                                           0.00     20.52 r\n  library setup time                      -0.11     20.41\n  data required time                               20.41\n  --------------------------------------------------------\n  slack (MET)                                       19.28\n</code></pre> <p>Note on \"library setup time: -0.11\": The negative value is correct. This represents the setup requirement of the flip-flop - data must arrive 0.11ns before the clock edge. In the calculation, it subtracts from the required time, giving data less time to arrive. This is standard timing report format.</p> <p>Note on clock period: This report uses a 20ns clock period (50 MHz), matching our course target frequency. The large positive slack (19.28ns) means our simple designs easily meet timing\u2014there's plenty of margin.</p>"},{"location":"notebooks/06_synthesis_physical_design/#key-things-to-check","title":"Key Things to Check\u00b6","text":"What Look For Slack Positive = good, negative = violation WNS Worst Negative Slack TNS Total Negative Slack Critical path Where is the bottleneck?"},{"location":"notebooks/06_synthesis_physical_design/#summary","title":"Summary\u00b6","text":"<ul> <li>Synthesis converts RTL to gate netlist</li> <li>Yosys is our open-source synthesis tool</li> <li>Standard cells are pre-designed building blocks</li> <li>Place &amp; Route creates physical layout</li> <li>STA verifies timing without simulation</li> </ul>"},{"location":"notebooks/06_synthesis_physical_design/#submitting-to-tiny-tapeout","title":"Submitting to Tiny Tapeout\u00b6","text":"<p>When you're ready to tape out, you'll submit:</p> <ul> <li>Your Verilog source files (the design and testbench)</li> <li>A GDS file (generated by the flow)</li> <li>Documentation (README, pinout diagram)</li> </ul> <p>The Tiny Tapeout GitHub template handles most of this automatically - see tinytapeout.com for the submission guide.</p>"},{"location":"notebooks/06_synthesis_physical_design/#homework","title":"Homework\u00b6","text":"<ol> <li>Synthesize your design - check gate count</li> <li>Run place and route</li> <li>Check timing reports - any violations?</li> <li>View layout in KLayout</li> </ol>"},{"location":"notebooks/07_packaging_board_design/","title":"Packaging & Board Design","text":"Packaging &amp; Board Design <p>Week 4, Session 1 \u2014 Fab Futures</p> In\u00a0[1]: Copied! <pre># Setup\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.patches import FancyBboxPatch, Circle, Rectangle, FancyArrowPatch\nimport numpy as np\n\nprint(\"Setup complete.\")\n</pre> # Setup import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.patches import FancyBboxPatch, Circle, Rectangle, FancyArrowPatch import numpy as np  print(\"Setup complete.\") <pre>Setup complete.\n</pre> <p></p> In\u00a0[2]: Copied! <pre># Package cross-section\nfig, ax = plt.subplots(figsize=(12, 6))\n\n# Leadframe / substrate\nax.add_patch(Rectangle((0, 0), 12, 0.5, facecolor='#FFD700', edgecolor='black', linewidth=2))\nax.text(6, 0.25, 'Leadframe / Substrate', ha='center', va='center', fontsize=10)\n\n# Die attach\nax.add_patch(Rectangle((4.5, 0.5), 3, 0.2, facecolor='#C0C0C0', edgecolor='black'))\nax.text(6, 0.6, 'Die attach', ha='center', va='center', fontsize=8)\n\n# Die\nax.add_patch(Rectangle((4.5, 0.7), 3, 1.2, facecolor='#4169E1', edgecolor='black', linewidth=2))\nax.text(6, 1.3, 'Silicon Die', ha='center', va='center', fontsize=11, color='white', fontweight='bold')\n\n# Bond pads on die\nfor i in range(5):\n    x = 4.8 + i * 0.5\n    ax.add_patch(Rectangle((x, 1.8), 0.3, 0.1, facecolor='gold', edgecolor='black'))\n\n# Wirebonds\nfor i in range(5):\n    x_die = 4.95 + i * 0.5\n    x_lead = 1 + i * 2.2\n    # Curved wirebond\n    t = np.linspace(0, 1, 50)\n    x = x_die + (x_lead - x_die) * t\n    y = 1.85 + 1.5 * np.sin(np.pi * t)\n    ax.plot(x, y, 'gold', linewidth=1.5)\n\n# Lead fingers\nfor i in range(5):\n    x = 1 + i * 2.2\n    ax.add_patch(Rectangle((x - 0.2, 0), 0.4, 0.3, facecolor='#FFD700', edgecolor='black'))\n\n# Mold compound outline\nax.add_patch(FancyBboxPatch((0.5, -0.2), 11, 4, boxstyle=\"round,pad=0.1\",\n             facecolor='none', edgecolor='#333', linewidth=2, linestyle='--'))\nax.text(10, 3.5, 'Mold\\nCompound', ha='center', fontsize=9)\n\n# Labels\nax.annotate('Bond wire', xy=(3, 2.5), fontsize=9,\n           bbox=dict(boxstyle='round', facecolor='lightyellow'))\nax.annotate('Bond pad', xy=(5.5, 2.1), fontsize=8)\n\nax.set_xlim(-0.5, 12.5)\nax.set_ylim(-0.5, 4.5)\nax.set_aspect('equal')\nax.set_title('Package Cross-Section', fontsize=14, fontweight='bold')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Package cross-section fig, ax = plt.subplots(figsize=(12, 6))  # Leadframe / substrate ax.add_patch(Rectangle((0, 0), 12, 0.5, facecolor='#FFD700', edgecolor='black', linewidth=2)) ax.text(6, 0.25, 'Leadframe / Substrate', ha='center', va='center', fontsize=10)  # Die attach ax.add_patch(Rectangle((4.5, 0.5), 3, 0.2, facecolor='#C0C0C0', edgecolor='black')) ax.text(6, 0.6, 'Die attach', ha='center', va='center', fontsize=8)  # Die ax.add_patch(Rectangle((4.5, 0.7), 3, 1.2, facecolor='#4169E1', edgecolor='black', linewidth=2)) ax.text(6, 1.3, 'Silicon Die', ha='center', va='center', fontsize=11, color='white', fontweight='bold')  # Bond pads on die for i in range(5):     x = 4.8 + i * 0.5     ax.add_patch(Rectangle((x, 1.8), 0.3, 0.1, facecolor='gold', edgecolor='black'))  # Wirebonds for i in range(5):     x_die = 4.95 + i * 0.5     x_lead = 1 + i * 2.2     # Curved wirebond     t = np.linspace(0, 1, 50)     x = x_die + (x_lead - x_die) * t     y = 1.85 + 1.5 * np.sin(np.pi * t)     ax.plot(x, y, 'gold', linewidth=1.5)  # Lead fingers for i in range(5):     x = 1 + i * 2.2     ax.add_patch(Rectangle((x - 0.2, 0), 0.4, 0.3, facecolor='#FFD700', edgecolor='black'))  # Mold compound outline ax.add_patch(FancyBboxPatch((0.5, -0.2), 11, 4, boxstyle=\"round,pad=0.1\",              facecolor='none', edgecolor='#333', linewidth=2, linestyle='--')) ax.text(10, 3.5, 'Mold\\nCompound', ha='center', fontsize=9)  # Labels ax.annotate('Bond wire', xy=(3, 2.5), fontsize=9,            bbox=dict(boxstyle='round', facecolor='lightyellow')) ax.annotate('Bond pad', xy=(5.5, 2.1), fontsize=8)  ax.set_xlim(-0.5, 12.5) ax.set_ylim(-0.5, 4.5) ax.set_aspect('equal') ax.set_title('Package Cross-Section', fontsize=14, fontweight='bold') ax.axis('off')  plt.tight_layout() plt.show() <p></p> In\u00a0[3]: Copied! <pre># Package types visualization\nfig, axes = plt.subplots(1, 4, figsize=(16, 4))\n\n# DIP\nax = axes[0]\nax.add_patch(Rectangle((1, 1), 3, 4, facecolor='#333', edgecolor='black', linewidth=2))\nfor i in range(8):\n    ax.add_patch(Rectangle((0.5, 1.3 + i*0.4), 0.5, 0.15, facecolor='#C0C0C0', edgecolor='black'))\n    ax.add_patch(Rectangle((4, 1.3 + i*0.4), 0.5, 0.15, facecolor='#C0C0C0', edgecolor='black'))\n# Notch\nax.add_patch(Circle((2.5, 5), 0.2, facecolor='#333', edgecolor='white', linewidth=2))\nax.set_xlim(0, 5)\nax.set_ylim(0, 6)\nax.set_title('DIP-16', fontsize=11, fontweight='bold')\nax.set_aspect('equal')\nax.axis('off')\n\n# QFP\nax = axes[1]\nax.add_patch(Rectangle((1, 1), 3, 3, facecolor='#333', edgecolor='black', linewidth=2))\nfor i in range(6):\n    # Top/bottom\n    ax.add_patch(Rectangle((1.3 + i*0.4, 4), 0.15, 0.4, facecolor='#C0C0C0', edgecolor='black'))\n    ax.add_patch(Rectangle((1.3 + i*0.4, 0.6), 0.15, 0.4, facecolor='#C0C0C0', edgecolor='black'))\n    # Left/right\n    ax.add_patch(Rectangle((0.6, 1.3 + i*0.4), 0.4, 0.15, facecolor='#C0C0C0', edgecolor='black'))\n    ax.add_patch(Rectangle((4, 1.3 + i*0.4), 0.4, 0.15, facecolor='#C0C0C0', edgecolor='black'))\nax.add_patch(Circle((1.3, 3.7), 0.15, facecolor='white'))\nax.set_xlim(0, 5)\nax.set_ylim(0, 5)\nax.set_title('QFP-48', fontsize=11, fontweight='bold')\nax.set_aspect('equal')\nax.axis('off')\n\n# QFN\nax = axes[2]\nax.add_patch(Rectangle((1, 1), 3, 3, facecolor='#333', edgecolor='black', linewidth=2))\nfor i in range(5):\n    ax.add_patch(Rectangle((1.4 + i*0.4, 0.95), 0.2, 0.3, facecolor='#C0C0C0', edgecolor='black'))\n    ax.add_patch(Rectangle((1.4 + i*0.4, 3.75), 0.2, 0.3, facecolor='#C0C0C0', edgecolor='black'))\n    ax.add_patch(Rectangle((0.95, 1.4 + i*0.4), 0.3, 0.2, facecolor='#C0C0C0', edgecolor='black'))\n    ax.add_patch(Rectangle((3.75, 1.4 + i*0.4), 0.3, 0.2, facecolor='#C0C0C0', edgecolor='black'))\n# Thermal pad\nax.add_patch(Rectangle((1.8, 1.8), 1.4, 1.4, facecolor='#C0C0C0', edgecolor='black'))\nax.add_patch(Circle((1.3, 3.5), 0.1, facecolor='white'))\nax.set_xlim(0, 5)\nax.set_ylim(0, 5)\nax.set_title('QFN-20', fontsize=11, fontweight='bold')\nax.set_aspect('equal')\nax.axis('off')\n\n# BGA\nax = axes[3]\nax.add_patch(Rectangle((0.5, 0.5), 4, 4, facecolor='#333', edgecolor='black', linewidth=2))\nfor i in range(6):\n    for j in range(6):\n        ax.add_patch(Circle((1 + i*0.6, 1 + j*0.6), 0.15, facecolor='#C0C0C0', edgecolor='black'))\nax.add_patch(Circle((1, 3.5), 0.1, facecolor='white'))\nax.set_xlim(0, 5)\nax.set_ylim(0, 5)\nax.set_title('BGA-36', fontsize=11, fontweight='bold')\nax.set_aspect('equal')\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> # Package types visualization fig, axes = plt.subplots(1, 4, figsize=(16, 4))  # DIP ax = axes[0] ax.add_patch(Rectangle((1, 1), 3, 4, facecolor='#333', edgecolor='black', linewidth=2)) for i in range(8):     ax.add_patch(Rectangle((0.5, 1.3 + i*0.4), 0.5, 0.15, facecolor='#C0C0C0', edgecolor='black'))     ax.add_patch(Rectangle((4, 1.3 + i*0.4), 0.5, 0.15, facecolor='#C0C0C0', edgecolor='black')) # Notch ax.add_patch(Circle((2.5, 5), 0.2, facecolor='#333', edgecolor='white', linewidth=2)) ax.set_xlim(0, 5) ax.set_ylim(0, 6) ax.set_title('DIP-16', fontsize=11, fontweight='bold') ax.set_aspect('equal') ax.axis('off')  # QFP ax = axes[1] ax.add_patch(Rectangle((1, 1), 3, 3, facecolor='#333', edgecolor='black', linewidth=2)) for i in range(6):     # Top/bottom     ax.add_patch(Rectangle((1.3 + i*0.4, 4), 0.15, 0.4, facecolor='#C0C0C0', edgecolor='black'))     ax.add_patch(Rectangle((1.3 + i*0.4, 0.6), 0.15, 0.4, facecolor='#C0C0C0', edgecolor='black'))     # Left/right     ax.add_patch(Rectangle((0.6, 1.3 + i*0.4), 0.4, 0.15, facecolor='#C0C0C0', edgecolor='black'))     ax.add_patch(Rectangle((4, 1.3 + i*0.4), 0.4, 0.15, facecolor='#C0C0C0', edgecolor='black')) ax.add_patch(Circle((1.3, 3.7), 0.15, facecolor='white')) ax.set_xlim(0, 5) ax.set_ylim(0, 5) ax.set_title('QFP-48', fontsize=11, fontweight='bold') ax.set_aspect('equal') ax.axis('off')  # QFN ax = axes[2] ax.add_patch(Rectangle((1, 1), 3, 3, facecolor='#333', edgecolor='black', linewidth=2)) for i in range(5):     ax.add_patch(Rectangle((1.4 + i*0.4, 0.95), 0.2, 0.3, facecolor='#C0C0C0', edgecolor='black'))     ax.add_patch(Rectangle((1.4 + i*0.4, 3.75), 0.2, 0.3, facecolor='#C0C0C0', edgecolor='black'))     ax.add_patch(Rectangle((0.95, 1.4 + i*0.4), 0.3, 0.2, facecolor='#C0C0C0', edgecolor='black'))     ax.add_patch(Rectangle((3.75, 1.4 + i*0.4), 0.3, 0.2, facecolor='#C0C0C0', edgecolor='black')) # Thermal pad ax.add_patch(Rectangle((1.8, 1.8), 1.4, 1.4, facecolor='#C0C0C0', edgecolor='black')) ax.add_patch(Circle((1.3, 3.5), 0.1, facecolor='white')) ax.set_xlim(0, 5) ax.set_ylim(0, 5) ax.set_title('QFN-20', fontsize=11, fontweight='bold') ax.set_aspect('equal') ax.axis('off')  # BGA ax = axes[3] ax.add_patch(Rectangle((0.5, 0.5), 4, 4, facecolor='#333', edgecolor='black', linewidth=2)) for i in range(6):     for j in range(6):         ax.add_patch(Circle((1 + i*0.6, 1 + j*0.6), 0.15, facecolor='#C0C0C0', edgecolor='black')) ax.add_patch(Circle((1, 3.5), 0.1, facecolor='white')) ax.set_xlim(0, 5) ax.set_ylim(0, 5) ax.set_title('BGA-36', fontsize=11, fontweight='bold') ax.set_aspect('equal') ax.axis('off')  plt.tight_layout() plt.show() <p></p> <p>Wirebonding connects the die pads to the package leads using thin gold or aluminum wires.</p> In\u00a0[4]: Copied! <pre># Wirebond diagram example\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Package outline\nax.add_patch(Rectangle((0, 0), 10, 10, facecolor='#F5F5F5', edgecolor='black', linewidth=2))\n\n# Die\nax.add_patch(Rectangle((3, 3), 4, 4, facecolor='#4169E1', edgecolor='black', linewidth=2))\nax.text(5, 5, 'DIE', ha='center', va='center', fontsize=14, color='white', fontweight='bold')\n\n# Package pins (simplified - 4 per side)\npin_labels = {\n    'top': ['NC', 'TX', 'LED', 'NC'],\n    'right': ['VDD', 'BTN', 'NC', 'GND'],\n    'bottom': ['NC', 'CLK', 'RST', 'NC'],\n    'left': ['GND', 'NC', 'NC', 'VDD']\n}\n\ncolors = {'VDD': '#F44336', 'GND': '#2196F3', 'CLK': '#9C27B0', \n          'RST': '#FF9800', 'TX': '#4CAF50', 'BTN': '#FFC107', \n          'LED': '#E91E63', 'NC': '#9E9E9E'}\n\n# Top pins\nfor i, label in enumerate(pin_labels['top']):\n    x = 2 + i * 2\n    ax.add_patch(Rectangle((x - 0.3, 9.5), 0.6, 0.4, facecolor=colors[label], edgecolor='black'))\n    ax.text(x, 10.2, label, ha='center', fontsize=8)\n    if label != 'NC':\n        ax.plot([x, x], [9.5, 7], colors[label], linewidth=1.5)\n\n# Bottom pins\nfor i, label in enumerate(pin_labels['bottom']):\n    x = 2 + i * 2\n    ax.add_patch(Rectangle((x - 0.3, 0.1), 0.6, 0.4, facecolor=colors[label], edgecolor='black'))\n    ax.text(x, -0.4, label, ha='center', fontsize=8)\n    if label != 'NC':\n        ax.plot([x, x], [0.5, 3], colors[label], linewidth=1.5)\n\n# Left pins\nfor i, label in enumerate(pin_labels['left']):\n    y = 2 + i * 2\n    ax.add_patch(Rectangle((0.1, y - 0.3), 0.4, 0.6, facecolor=colors[label], edgecolor='black'))\n    ax.text(-0.4, y, label, ha='center', va='center', fontsize=8, rotation=90)\n    if label != 'NC':\n        ax.plot([0.5, 3], [y, y], colors[label], linewidth=1.5)\n\n# Right pins\nfor i, label in enumerate(pin_labels['right']):\n    y = 2 + i * 2\n    ax.add_patch(Rectangle((9.5, y - 0.3), 0.4, 0.6, facecolor=colors[label], edgecolor='black'))\n    ax.text(10.4, y, label, ha='center', va='center', fontsize=8, rotation=90)\n    if label != 'NC':\n        ax.plot([9.5, 7], [y, y], colors[label], linewidth=1.5)\n\n# Die pads (simplified)\ndie_pads = [\n    (3.2, 6.8, 'TX'), (5, 6.8, 'LED'),\n    (6.8, 5.5, 'VDD'), (6.8, 4.5, 'BTN'),\n    (6.8, 3.5, 'GND'),\n    (5, 3.2, 'CLK'), (4, 3.2, 'RST'),\n    (3.2, 4.5, 'GND'), (3.2, 5.5, 'VDD'),\n]\n\nfor x, y, label in die_pads:\n    ax.add_patch(Rectangle((x - 0.15, y - 0.15), 0.3, 0.3, \n                           facecolor='gold', edgecolor='black'))\n\nax.set_xlim(-1, 11)\nax.set_ylim(-1, 11)\nax.set_aspect('equal')\nax.set_title('Wirebond Diagram Example', fontsize=14, fontweight='bold')\nax.axis('off')\n\n# Legend\nax.text(8, -0.8, 'VDD=Power  GND=Ground  NC=No Connect', fontsize=8)\n\nplt.tight_layout()\nplt.show()\n</pre> # Wirebond diagram example fig, ax = plt.subplots(figsize=(10, 10))  # Package outline ax.add_patch(Rectangle((0, 0), 10, 10, facecolor='#F5F5F5', edgecolor='black', linewidth=2))  # Die ax.add_patch(Rectangle((3, 3), 4, 4, facecolor='#4169E1', edgecolor='black', linewidth=2)) ax.text(5, 5, 'DIE', ha='center', va='center', fontsize=14, color='white', fontweight='bold')  # Package pins (simplified - 4 per side) pin_labels = {     'top': ['NC', 'TX', 'LED', 'NC'],     'right': ['VDD', 'BTN', 'NC', 'GND'],     'bottom': ['NC', 'CLK', 'RST', 'NC'],     'left': ['GND', 'NC', 'NC', 'VDD'] }  colors = {'VDD': '#F44336', 'GND': '#2196F3', 'CLK': '#9C27B0',            'RST': '#FF9800', 'TX': '#4CAF50', 'BTN': '#FFC107',            'LED': '#E91E63', 'NC': '#9E9E9E'}  # Top pins for i, label in enumerate(pin_labels['top']):     x = 2 + i * 2     ax.add_patch(Rectangle((x - 0.3, 9.5), 0.6, 0.4, facecolor=colors[label], edgecolor='black'))     ax.text(x, 10.2, label, ha='center', fontsize=8)     if label != 'NC':         ax.plot([x, x], [9.5, 7], colors[label], linewidth=1.5)  # Bottom pins for i, label in enumerate(pin_labels['bottom']):     x = 2 + i * 2     ax.add_patch(Rectangle((x - 0.3, 0.1), 0.6, 0.4, facecolor=colors[label], edgecolor='black'))     ax.text(x, -0.4, label, ha='center', fontsize=8)     if label != 'NC':         ax.plot([x, x], [0.5, 3], colors[label], linewidth=1.5)  # Left pins for i, label in enumerate(pin_labels['left']):     y = 2 + i * 2     ax.add_patch(Rectangle((0.1, y - 0.3), 0.4, 0.6, facecolor=colors[label], edgecolor='black'))     ax.text(-0.4, y, label, ha='center', va='center', fontsize=8, rotation=90)     if label != 'NC':         ax.plot([0.5, 3], [y, y], colors[label], linewidth=1.5)  # Right pins for i, label in enumerate(pin_labels['right']):     y = 2 + i * 2     ax.add_patch(Rectangle((9.5, y - 0.3), 0.4, 0.6, facecolor=colors[label], edgecolor='black'))     ax.text(10.4, y, label, ha='center', va='center', fontsize=8, rotation=90)     if label != 'NC':         ax.plot([9.5, 7], [y, y], colors[label], linewidth=1.5)  # Die pads (simplified) die_pads = [     (3.2, 6.8, 'TX'), (5, 6.8, 'LED'),     (6.8, 5.5, 'VDD'), (6.8, 4.5, 'BTN'),     (6.8, 3.5, 'GND'),     (5, 3.2, 'CLK'), (4, 3.2, 'RST'),     (3.2, 4.5, 'GND'), (3.2, 5.5, 'VDD'), ]  for x, y, label in die_pads:     ax.add_patch(Rectangle((x - 0.15, y - 0.15), 0.3, 0.3,                             facecolor='gold', edgecolor='black'))  ax.set_xlim(-1, 11) ax.set_ylim(-1, 11) ax.set_aspect('equal') ax.set_title('Wirebond Diagram Example', fontsize=14, fontweight='bold') ax.axis('off')  # Legend ax.text(8, -0.8, 'VDD=Power  GND=Ground  NC=No Connect', fontsize=8)  plt.tight_layout() plt.show() <p></p> <p>An evaluation board (eval board) lets you test your chip by providing:</p> Feature Purpose Power supply Clean VDD and GND Decoupling capacitors Filter power noise Clock source Crystal or oscillator Reset circuit Power-on reset I/O connectors Access to chip pins Debug headers Logic analyzer, JTAG <p></p> <p></p>"},{"location":"notebooks/07_packaging_board_design/#contents","title":"Contents\u00b6","text":"<ol> <li>Why Packaging Matters</li> <li>Package Types</li> <li>Wirebonding</li> <li>Flip-Chip &amp; Advanced Packaging</li> <li>Eval Board Design</li> <li>Bring-Up &amp; Testing</li> <li>Debug Techniques</li> </ol>"},{"location":"notebooks/07_packaging_board_design/#1-chip-packaging-overview","title":"1. Chip Packaging Overview\u00b6","text":""},{"location":"notebooks/07_packaging_board_design/#why-package-a-chip","title":"Why Package a Chip?\u00b6","text":"<p>The silicon die is tiny and fragile. Packaging provides:</p> Function Description Protection Mechanical, chemical, thermal protection Connectivity Route signals from tiny pads to solderable pins Heat dissipation Remove heat from the die Handling Makes the chip easy to place on a board"},{"location":"notebooks/07_packaging_board_design/#from-wafer-to-package","title":"From Wafer to Package\u00b6","text":"<pre><code>Wafer \u2192 Dicing \u2192 Die Attach \u2192 Wirebond \u2192 Encapsulation \u2192 Test\n</code></pre>"},{"location":"notebooks/07_packaging_board_design/#2-package-types","title":"2. Package Types\u00b6","text":""},{"location":"notebooks/07_packaging_board_design/#through-hole-packages-older-easier-to-prototype","title":"Through-Hole Packages (older, easier to prototype)\u00b6","text":"Package Pins Notes DIP (Dual In-line) 8-64 Breadboard-friendly! SIP (Single In-line) 4-24 Memory modules PGA (Pin Grid Array) 100+ Old CPUs"},{"location":"notebooks/07_packaging_board_design/#surface-mount-packages-modern","title":"Surface Mount Packages (modern)\u00b6","text":"Package Pins Notes SOIC 8-28 Standard small outline QFP (Quad Flat Pack) 32-200+ Leads on 4 sides QFN (Quad Flat No-lead) 8-100+ No leads, just pads BGA (Ball Grid Array) 100-1000+ Balls underneath"},{"location":"notebooks/07_packaging_board_design/#for-our-class","title":"For Our Class\u00b6","text":"<p>Educational tapeouts often use:</p> <ul> <li>QFN packages (small, easy to route)</li> <li>Bare die on carrier boards</li> <li>Chip-on-board (wirebond directly to PCB)</li> </ul>"},{"location":"notebooks/07_packaging_board_design/#3-wirebonding","title":"3. Wirebonding\u00b6","text":""},{"location":"notebooks/07_packaging_board_design/#wirebond-characteristics","title":"Wirebond Characteristics\u00b6","text":"Parameter Typical Value Why It Matters Wire diameter 18-50 \u00b5m Thicker = more current, but harder to bond Loop height 75-200 \u00b5m Must clear die features; affects inductance Bond pad size 50-100 \u00b5m Must match your design's pad size Wire length &lt; 5 mm typical Longer = more inductance, resistance"},{"location":"notebooks/07_packaging_board_design/#wirebond-diagram","title":"Wirebond Diagram\u00b6","text":"<p>For your design, you need to specify:</p> <ul> <li>Which die pad connects to which package pin</li> <li>Power (VDD) and Ground (GND) assignments</li> <li>Any special requirements (short wires for high-speed signals)</li> </ul> <p>Tip: Keep power/ground pads on opposite sides of the die from signal pads to simplify routing and reduce noise coupling.</p>"},{"location":"notebooks/07_packaging_board_design/#4-evaluation-board-design","title":"4. Evaluation Board Design\u00b6","text":""},{"location":"notebooks/07_packaging_board_design/#typical-eval-board-components","title":"Typical Eval Board Components\u00b6","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502Power\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502USB-UART\u2502 \u2502\n\u2502  \u2502 In  \u2502    \u2502         \u2502      \u2502 Bridge \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u252c\u2500\u2500\u2518    \u2502  YOUR   \u2502      \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502     \u2502       \u2502  CHIP   \u2502          \u2502      \u2502\n\u2502  \u250c\u2500\u2500\u2534\u2500\u2500\u2510    \u2502         \u2502      \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502Vreg \u2502    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518      \u2502Headers\u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502           \u2502Decap \u2502 Xtal \u2502               \u2502\n\u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"notebooks/07_packaging_board_design/#kicad-for-pcb-design","title":"KiCad for PCB Design\u00b6","text":"<p>KiCad is a free, open-source PCB design tool.</p> <p>Basic workflow:</p> <ol> <li>Schematic - Draw circuit connections</li> <li>Footprints - Assign physical package shapes</li> <li>Layout - Place components and route traces</li> <li>Gerbers - Export manufacturing files</li> </ol> <p>PCB fabs for prototypes:</p> <ul> <li>JLCPCB (~$2 for 5 boards)</li> <li>PCBWay</li> <li>OSH Park (purple boards!)</li> </ul>"},{"location":"notebooks/07_packaging_board_design/#5-testing-your-chip","title":"5. Testing Your Chip\u00b6","text":""},{"location":"notebooks/07_packaging_board_design/#test-setup","title":"Test Setup\u00b6","text":"Equipment Purpose Power supply Provide VDD (often 1.8V or 3.3V) Multimeter Measure voltage, current Oscilloscope See digital signals Logic analyzer Capture many digital signals USB-UART adapter Serial communication with laptop"},{"location":"notebooks/07_packaging_board_design/#test-plan-template","title":"Test Plan Template\u00b6","text":"<ol> <li><p>Power-up test</p> <ul> <li>Does the chip draw expected current?</li> <li>No smoke? (seriously, check this first!)</li> </ul> </li> <li><p>Basic functionality</p> <ul> <li>Does reset work?</li> <li>Can you see clock activity?</li> <li>Do outputs toggle?</li> </ul> </li> <li><p>Feature tests</p> <ul> <li>Test each feature of your design</li> <li>Compare to simulation results</li> </ul> </li> </ol>"},{"location":"notebooks/07_packaging_board_design/#for-our-projects","title":"For Our Projects\u00b6","text":"Project Test Method Fortune Teller Press button, see output on serial terminal Pocket Synth Press keys, listen to speaker Dice Roller Press button, see 7-segment display LED Messenger Power up, see LEDs animate"},{"location":"notebooks/07_packaging_board_design/#6-debug-techniques","title":"6. Debug Techniques\u00b6","text":""},{"location":"notebooks/07_packaging_board_design/#when-things-dont-work","title":"When Things Don't Work\u00b6","text":"Symptom Check No power Solder joints, voltage at pins High current Short circuit, wrong voltage No activity Clock, reset, enable signals Wrong output Input values, state machine Glitchy output Power supply noise, timing"},{"location":"notebooks/07_packaging_board_design/#debug-strategies","title":"Debug Strategies\u00b6","text":"<ol> <li><p>Divide and conquer</p> <ul> <li>Isolate which block is failing</li> <li>Test inputs and outputs of each block</li> </ul> </li> <li><p>Compare to simulation</p> <ul> <li>Apply same inputs as testbench</li> <li>Do outputs match?</li> </ul> </li> <li><p>Add observability</p> <ul> <li>Route internal signals to spare pins</li> <li>Add debug registers (if you planned ahead!)</li> </ul> </li> </ol>"},{"location":"notebooks/07_packaging_board_design/#design-for-debug-dfd","title":"Design for Debug (DFD)\u00b6","text":"<p>Plan ahead in your design:</p> <ul> <li>Spare I/O pins for probing internal signals</li> <li>Bypass modes to isolate blocks</li> <li>Status registers readable via serial</li> </ul>"},{"location":"notebooks/07_packaging_board_design/#summary","title":"Summary\u00b6","text":"<ul> <li>Packaging protects the die and provides connectivity</li> <li>Wirebonding connects die pads to package pins</li> <li>Eval boards provide power, clock, and I/O access</li> <li>Testing verifies your chip works in silicon</li> <li>Debug requires planning and systematic approach</li> </ul>"},{"location":"notebooks/07_packaging_board_design/#homework","title":"Homework\u00b6","text":"<ol> <li>Run final DRC/LVS on your design</li> <li>Document your pin assignments</li> <li>Create a test plan</li> <li>Prepare your presentation for Thursday!</li> </ol>"}]}